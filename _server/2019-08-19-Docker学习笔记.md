| layout | title          | categories | tags                   | author |
| ------ | -------------- | ---------- | ---------------------- | ------ |
| server | docker随手笔记 | server     | docker、docker-compose | 李文功 |

 

[TOC]



## 什么是 Docker

Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。

 

## 为什么要使用 Docker？

作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。

**1、更高效的利用系统资源**

由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。

**2、更快速的启动时间**

传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。

**3、一致的运行环境**

开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。

**4、持续交付和部署**

对开发和运维（DevOps） 人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。

使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile 来进行镜像构建，并结合持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署(Continuous Delivery/Deployment) 系统进行自动部署。

而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。

**5、更轻松的迁移**

由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。

**6、更轻松的维护和扩展**

Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。

 



# 基本概念

Docker 包括三个基本概念

镜像（Image ）

容器（Container ）

仓库（Repository ）

理解了这三个概念，就理解了 Docker 的整个生命周期。

 

## Docker 镜像

Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等） 。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

 

### 分层存储

在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。

镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理

掉。

分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。

 

## Docker 容器

镜像（Image ） 和容器（Container ） 的关系，就像是面向对象程序设计中的 类 和 实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

 

 

## Docker Registry

镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。

 

### Docker Registry 公开服务

Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。

最常使用的 Registry 公开服务是官方的 Docker Hub(https://hub.docker.com)，这也是默认的 Registry，并拥有大量的高质量的官方镜像。

国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror ） ，这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接

从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。

国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓库(https://hub.tenxcloud.com/)、网易云镜像服务(https://id.163yun.com)、DaoCloud 镜像市场(https://hub.daocloud.io/)、阿里云镜像库(https://cr.console.aliyun.com)等。

 

 

### 私有 Docker Registry

除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了Docker Registry 镜像，可以直接使用做为私有 Registry 服务。

开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。

除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 Sonatype Nexus。

 

 

 

# 安装 Docker

 

## Ubuntu 安装 Docker CE

 

**卸载旧版本**

旧版本的 Docker 称为 docker 或者 docker-engine ，使用以下命令卸载旧版本：

$ sudo apt-get remove docker \

docker-engine \

docker.io

 

 

**使用 APT 安装**

由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用

HTTPS 传输的软件包以及 CA 证书。

$ sudo apt-get update

$ sudo apt-get install \

apt-transport-https \

ca-certificates \

curl \

software-properties-common

 

鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。

为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。

$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -

 

\# 官方源

\# $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

 

然后，我们需要向 source.list 中添加 Docker 软件源

$ sudo add-apt-repository \

"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \

$(lsb_release -cs) \

stable"

 

\# 官方源

$ sudo add-apt-repository \

​       "deb [arch=amd64] https://download.docker.com/linux/ubuntu \

​      $(lsb_release -cs) \

​      stable"

 

$ sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs)        stable"

 

 

**安装 Docker CE**

更新 apt 软件包缓存，并安装 docker-ce ：

$ sudo apt-get update

$ sudo apt-get install docker-ce

 

 

## CentOS 安装 Docker CE

 

**系统要求**

Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。

 

**卸载旧版本**

旧版本的 Docker 称为 docker 或者 docker-engine ，使用以下命令卸载旧版本：

$ sudo yum remove docker \

docker-client \

docker-client-latest \

docker-common \

docker-latest \

docker-latest-logrotate \

docker-logrotate \

docker-selinux \

docker-engine-selinux \

docker-engine

 

**使用 yum 安装***

执行以下命令安装依赖包：

$ sudo yum install -y yum-utils \

device-mapper-persistent-data \

lvm2

鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。

执行下面的命令添加 yum 软件源：

 

$ sudo yum-config-manager \

--add-repo \

https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo

 

\# 官方源

\# $ sudo yum-config-manager \

\#    --add-repo \

\#    https://download.docker.com/linux/centos/docker-ce.repo

 

**安装 Docker CE**

更新 yum 软件源缓存，并安装 docker-ce 。

$ sudo yum makecache fast

$ sudo yum install docker-ce

 

 

## 公共部分

 

### 使用脚本自动安装

在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS

系统上可以使用这套脚本安装：

$ curl -fsSL get.docker.com -o get-docker.sh

$ sudo sh get-docker.sh --mirror Aliyun

 

### 启动 Docker CE

$ sudo systemctl enable docker

$ sudo systemctl start docker

 

### 建立 docker 用户组

默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和

docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统

上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker

用户组。

建立 docker 组：

$ sudo groupadd docker

将当前用户加入 docker 组：

$ sudo usermod -aG docker $USER

退出当前终端并重新登录，进行如下测试

 

### 测试 Docker 是否安装正确

$ docker run hello-world

 

 

## **镜像加速器**

 

我们以 Docker 官方加速器为例进行介绍。

**Ubuntu 14.04**、**Debian 7 Wheezy**

对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址：

DOCKER_OPTS="--registry-mirror=https://registry.docker-cn.com"

重新启动服务。

$ sudo service docker restart

 

**Ubuntu 16.04+**、**Debian 8+**、**CentOS 7**

对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）

$ vi /etc/docker/daemon.json

 

{

​        "registry-mirrors":[

​                "https://registry.docker-cn.com"

​        ]

}

注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。

之后重新启动服务。

$ sudo systemctl daemon-reload

$ sudo systemctl restart docker

 

 

# Ubuntu 18.04 Bionic Beaver安装Docker CE

 

**卸载旧版本**

旧版本的 Docker 称为 docker 或者 docker-engine ，使用以下命令卸载旧版本：

 

$ sudo apt remove docker \

docker-engine \

docker.io

 

Reading package lists... Done

Building dependency tree      

Reading state information... Done

Package 'docker-engine' is not installed, so not removed

Package 'docker' is not installed, so not removed

The following packages were automatically installed and are no longer required:

  bridge-utils cgroupfs-mount libltdl7 ubuntu-fan

Use 'sudo apt autoremove' to remove them.

The following packages will be REMOVED:

  docker.io

0 upgraded, 0 newly installed, 1 to remove and 0 not upgraded.

After this operation, 137 MB disk space will be freed.

Do you want to continue? [Y/n] y

(Reading database ... 74523 files and directories currently installed.)

Removing docker.io (17.12.1-0ubuntu1) ...

'/usr/share/docker.io/contrib/nuke-graph-directory.sh' -> '/var/lib/docker/nuke-graph-directory.sh'

Processing triggers for man-db (2.8.3-2) ...

 

**从Ubuntu仓库安装**

 

Installation from the standard Ubuntu repository consists of a single apt command. It may yield stable but lower docker version number:

$ sudo apt install docker.io

The following commands will start Docker and ensure that starts after the reboot:

$ sudo systemctl start docker$ sudo systemctl enable docker

All done.

$ docker --version

Docker version 17.12.1-ce, build 7390fc6

 

 

**从官方Docker仓库安装**

 

- **安装依赖**

Docker has its own repositories. Before you can install it from those repos, you need to install the prerequisite dependencies. Update your system, and grab them with Apt.



$ sudo apt update$ sudo apt install apt-transport-https ca-certificates curl software-properties-common

- **增加Docker仓库**

Create a new file for the Docker repository at /etc/apt/sources.list.d/docker.list. In that file, place the following line.

deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable

**WARNING:** As of now, Bionic is not supported by this repository. Make sure it is at the time you do this. If not, Artful can work as a temporary substitute hence replace the above bionic keyword with artful. Next, you need to add Docker's GPG key.

$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -

Once, that's imported, update Apt again.

$ sudo apt update

- **安装Docker CE**

You can simply install the Docker CE package.

$ sudo apt install docker-ce

Done. Check for docker version:

$ docker --versionDocker version 18.03.0-ce, build 0520e24

 

 

**从package安装**

If you cannot use Docker’s repository to install Docker CE, you can download the .deb file for your release and install it manually. You need to download a new file each time you want to upgrade Docker CE.

1. Go to <https://download.docker.com/linux/ubuntu/dists/>, choose your Ubuntu version, browse to pool/stable/and choose amd64, armhf, ppc64el, or s390x. Download the .deb file for the Docker version you want to install.

**Note**: To install an **edge** package, change the word stable in the URL to edge. [Learn about **stable** and **edge** channels](https://docs.docker.com/install/).

**$ cd /opt/docker**

**$ sudo wget https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/docker-ce_18.03.1~ce-0~ubuntu_amd64.deb**

1. Install Docker CE, changing the path below to the path where you downloaded the Docker package.
2. $ sudo dpkg -i**/opt/docker**/**docker-ce_18.03.1~ce-0~ubuntu_amd64.deb**

(Reading database ... 74329 files and directories currently installed.)

Preparing to unpack .../docker-ce_18.03.1~ce-0~ubuntu_amd64.deb ...

Unpacking docker-ce (18.03.1~ce-0~ubuntu) ...

Setting up docker-ce (18.03.1~ce-0~ubuntu) ...

Installing new version of config file /etc/init.d/docker ...

Installing new version of config file /etc/init/docker.conf ...

Processing triggers for ureadahead (0.100.0-20) ...

Processing triggers for systemd (237-3ubuntu10) ...

Processing triggers for man-db (2.8.3-2) ...

 

The Docker daemon starts automatically.

查看版本

$ docker --version

Docker version 18.03.1-ce, build 9ee9f40

 

1. Verify that Docker CE is installed correctly by running the hello-world
2. $ sudo docker run hello-world

This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.

 

 

# 使用镜像

 

## **获取镜像**

 

从 Docker 镜像仓库获取镜像的命令是 docker pull 。其命令格式为：
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]

 

具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。

- Docker 镜像仓库地址：地址的格式一般是 <域名/IP>[:端口号] 。默认地址是 Docker Hub。
- 仓库名：如之前所说，这里的仓库名是两段式名称，即 <用户名>/<软件名> 。对于 Docker Hub，如果不给出用户名，则默认为 library ，也就是官方镜像。

 

\# docker pull --help

Usage:  docker pull [OPTIONS] NAME[:TAG|@DIGEST]

 

Pull an image or a repository from a registry

 

Options:

  -a, --all-tags                Download all tagged images in the repository

​      --disable-content-trust   Skip image verification (default true)

 

## 列出镜像

要想列出已经下载下来的镜像，可以使用 docker image ls 命令。

 

以特定格式显示

 

对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。

$ docker image ls --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}"

IMAGE ID REPOSITORY TAG

5f515359c7f8 redis latest

05a60462f8ba nginx latest

fe9198c04d62 mongo 3.2

00285df0df87 <none> <none>

f753707788c5 ubuntu 16.04

f753707788c5 ubuntu latest

1e0c3dd64ccd ubuntu 14.04

 

## 删除本地镜像

如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：

$ docker image rm [选项] <镜像1> [<镜像2> ...]

 

用 ID、镜像名、摘要删除镜像

其中， <镜像> 可以是 镜像短 ID 、 镜像长 ID 、 镜像名 或者 镜像摘要 。

比如我们有这么一些镜像：

$ docker image ls

REPOSITORY TAG IMAGE ID CREATED  SIZE

centos latest 0584b3d2cf6d 3 weeks ago  196.5 MB

redis alpine 501ad78535f0 3 weeks ago  21.03 MB

docker latest cf693ec9b5c7 3 weeks ago  105.1 MB

nginx latest e43d811ce2f4 5 weeks ago  181.5 MB

 

 

我们也可以用 镜像名 ，也就是 <仓库名>:<标签> ，来删除镜像。

$ docker image rm centos

 

当然，更精确的是使用 镜像摘要 删除镜像。

$ docker image ls --digests

 

### Untagged 和 Deleted

​       当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 dockerrmi 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。

 

### 用 docker image ls 命令来配合

像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用 docker

image rm ，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像

列表的方式都可以拿过来使用。

比如，我们需要删除所有仓库名为 redis 的镜像：

$ docker image rm $(docker image ls -q redis)

 

 

## 利用 commit 理解镜像构成

 

当我们运行一个容器的时候（如果不使用卷的话） ，我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。

docker commit 的语法格式为：

docker commit [选项] <容器ID或容器名> [<仓库名>[:<标签>]]

 

慎用 **docker commit**

 

 

## 使用 Dockerfile 定制镜像

### Dockerfile

Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。

在一个空白目录中，建立一个文本文件，并命名为 Dockerfile ：

$ cd /opt/docker

$ mkdir mynginx

$ cd mynginx

$ touch Dockerfile

其内容为：

FROM nginx

RUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html

这个 Dockerfile 很简单，一共就两行。涉及到了两条指令， FROM 和 RUN 。

### 构建镜像

docker build [选项] <上下文路径/URL/->

 

$ docker build --help

 

Usage:  docker build [OPTIONS] PATH | URL | -

 

Build an image from a Dockerfile

 

Options:

​      --add-host list           Add a custom host-to-IP mapping (host:ip)

​      --build-arg list          Set build-time variables

​      --cache-from strings      Images to consider as cache sources

​      --cgroup-parent string    Optional parent cgroup for the container

​      --compress                Compress the build context using gzip

​      --cpu-period int          Limit the CPU CFS (Completely Fair Scheduler) period

​      --cpu-quota int           Limit the CPU CFS (Completely Fair Scheduler) quota

  -c, --cpu-shares int          CPU shares (relative weight)

​      --cpuset-cpus string      CPUs in which to allow execution (0-3, 0,1)

​      --cpuset-mems string      MEMs in which to allow execution (0-3, 0,1)

​      --disable-content-trust   Skip image verification (default true)

  -f, --file string             Name of the Dockerfile (Default is 'PATH/Dockerfile')

​      --force-rm                Always remove intermediate containers

​      --iidfile string          Write the image ID to the file

​      --isolation string        Container isolation technology

​      --label list              Set metadata for an image

  -m, --memory bytes            Memory limit

​      --memory-swap bytes       Swap limit equal to memory plus swap: '-1' to enable unlimited swap

​      --network string          Set the networking mode for the RUN instructions during build (default "default")

​      --no-cache                Do not use cache when building the image

​      --pull                    Always attempt to pull a newer version of the image

  -q, --quiet                   Suppress the build output and print image ID on success

​      --rm                      Remove intermediate containers after a successful build (default true)

​      --security-opt strings    Security options

​      --shm-size bytes          Size of /dev/shm

  -t, --tag list                Name and optionally a tag in the 'name:tag' format

​      --target string           Set the target build stage to build.

​      --ulimit ulimit           Ulimit options (default [])

 

 

$ docker build -t nginx:v3 .

Sending build context to Docker daemon  2.048kB

Step 1/2 : FROM nginx

latest: Pulling from library/nginx

f2aa67a397c4: Pull complete

3c091c23e29d: Pull complete

4a99993b8636: Pull complete

Digest: sha256:0fb320e2a1b1620b4905facb3447e3d84ad36da0b2c8aa8fe3a5a81d1187b884

Status: Downloaded newer image for nginx:latest

 ---> ae513a47849c

Step 2/2 : RUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html

 ---> Running in 2fd7301b0821

Removing intermediate container 2fd7301b0821

 ---> f7902d7882cd

Successfully built f7902d7882cd

Successfully tagged nginx:v3

 

### 镜像构建上下文（Context）

这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径， docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。

 

 

## **多阶段构建**

 

 

## 其它制作镜像的方式

除了标准的使用 Dockerfile 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。

### 从 rootfs 压缩包导入

 

格式： docker import [选项] <文件>|<URL>|- [<仓库名>[:<标签>]]

 

 

## 镜像的实现原理

 

Docker 镜像是怎么实现增量的修改和维护的？

每个镜像都由很多层次构成，Docker 使用 Union FS 将这些不同的层结合到一个镜像中去。

通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。

Docker 在 AUFS 上构建的容器也是利用了类似的原理。

 

 

# 操作 Docker 容器

 

简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。

 

 

## 启动容器

 

启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped ） 的容器重新启动。

因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。

 

### 新建并启动

所需要的命令主要为 docker run 。

$ docker run ubuntu:16.04 /bin/echo 'Hello world'

Hello world

 

下面的命令则启动一个 bash 终端，允许用户进行交互。

$ docker run -t -i ubuntu:16.04 /bin/bash

 

 

### 启动已终止容器

可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。

 

root@ubuntu16:~# docker container start --help

 

Usage:  docker container start [OPTIONS] CONTAINER [CONTAINER...]

 

Start one or more stopped containers

 

Options:

  -a, --attach               Attach STDOUT/STDERR and forward signals

​      --detach-keys string   Override the key sequence for detaching a container

  -i, --interactive          Attach container's STDIN

 

 

## 后台运行

更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。

此时，可以通过添加 -d 参数来实现。

 

如果不使用 -d 参数运行容器。

$ docker run ubuntu:16.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"

hello world

hello world

hello world

hello world

容器会把输出的结果 (STDOUT) 打印到宿主机上面

 

如果使用了 -d 参数运行容器。

$ docker run -d ubuntu:16.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"

77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a

此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用docker logs 查看)。

 

 

注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。

使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls 命令来查看容器信息。

 

 

## 终止容器

可以使用 docker container stop 来终止一个运行中的容器。

 

终止状态的容器可以用 docker container ls -a 命令看到。例如

$ docker container ls -a

 

 

## 进入容器

在使用 -d 参数时，容器启动后会进入后台。

某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。

 

### attach 命令

docker attach 是 Docker 自带的命令。

 

root@ubuntu16:~# docker attach --help

 

Usage:  docker attach [OPTIONS] CONTAINER

 

Attach local standard input, output, and error streams to a running container

 

Options:

​      --detach-keys string   Override the key sequence for detaching a container

​      --no-stdin             Do not attach STDIN

​      --sig-proxy            Proxy all received signals to the process (default true)

 

### exec 命令

 

root@ubuntu16:~# docker exec --help

 

Usage:  docker exec [OPTIONS] CONTAINER COMMAND [ARG...]

 

Run a command in a running container

 

Options:

  -d, --detach               Detached mode: run command in the background

​      --detach-keys string   Override the key sequence for detaching a container

  -e, --env list             Set environment variables

  -i, --interactive          Keep STDIN open even if not attached

​      --privileged           Give extended privileges to the command

  -t, --tty                  Allocate a pseudo-TTY

  -u, --user string          Username or UID (format: <name|uid>[:<group|gid>])

  -w, --workdir string       Working directory inside the container

 

$ docker run -dit ubuntu:16.04

 

$ docker container ls

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

93d7e66e36eb        ubuntu:16.04        "/bin/bash"         11 seconds ago      Up 10 seconds                           eager_mccarthy

 

$ docker exec -i 93d7 bash

 

 

$ docker exec -it 93d7 bash

 

如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。

 

 

## 导出和导入容器

 

### 导出容器

如果要导出本地某个容器，可以使用 docker export 命令。

$ docker container ls -a

CONTAINER ID    IMAGE   COMMAND   CREATED   STATUS   PORTS   NAMES

7691a814370e   ubuntu:14.04  "/bin/bash"  36 hours ago  Exited (0)   21 hours ago   test

$ docker export 7691a814370e > ubuntu.tar

这样将导出容器快照到本地文件。

 

### 导入容器快照

可以使用 docker import 从容器快照文件中再导入为镜像，例如

$ cat ubuntu.tar | docker import - test/ubuntu:v1.0

$ docker image ls

REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE

test/ubuntu v1.0 9d37a6082e97 About a minute ago 171.3MB

此外，也可以通过指定 URL 或者某个目录来导入，例如

$ docker import http://example.com/exampleimage.tgz example/imagerepo

 

注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态） ，而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。

 

 

## 删除容器

可以使用 docker container rm 来删除一个处于终止状态的容器。例如

$ docker container rm trusting_newton

trusting_newton

如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。

 

### 清理所有处于终止状态的容器

用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太

多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。

$ docker container prune

 

 

# 访问仓库

仓库（Repository ） 是集中存放镜像的地方。

一个容易混淆的概念是注册服务器（Registry ） 。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 dl.dockerpool.com/ubuntu 来说， dl.dockerpool.com 是注册服务器地址， ubuntu 是仓库名。

 

## Docker Hub

目前 Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 15,000 的镜

像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。

 

 

### 拉取镜像

你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它

下载到本地。

例如以 centos 为关键词进行搜索：

$ docker search centos

 

下载官方 centos 镜像到本地。

$ docker pull centos

 

 

### 推送镜像

用户也可以在登录后通过 docker push 命令来将自己的镜像推送到 Docker Hub。

以下命令中的 username 请替换为你的 Docker 账号用户名。

$ docker tag ubuntu:17.10 username/ubuntu:17.10

$ docker image ls

REPOSITORY   TAG   IMAGE ID   CREATED   SIZE

ubuntu   17.10   275d79   972a86   6 days ago   94.6MB

username/ubuntu 17.10 275d79

972a86 6 days ago 94.6MB

$ docker push username/ubuntu:17.10

$ docker search username

NAME DESCRIPTION STARS

OFFICIAL AUTOMATED

username/ubuntu

 

 

### 自动创建

自动创建（Automated Builds） 功能对于需要经常升级镜像内程序来说，十分方便。

有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。

而自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 GitHub 或BitBucket） 上的项目，一旦项目发生新的提交或者创建新的标签（tag） ，Docker Hub 会自动构建镜像并推送到 Docker Hub 中。

 

要配置自动创建，包括如下的步骤：

创建并登录 Docker Hub，以及目标网站；

在目标网站中连接帐户到 Docker Hub；

在 Docker Hub 中 配置一个自动创建；

选取一个目标网站中的项目（需要含 Dockerfile ） 和分支；

指定 Dockerfile 的位置，并提交创建。

之后，可以在 Docker Hub 的 自动创建页面 中跟踪每次创建的状态。

 

 

## 私有仓库

有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。

本节介绍如何使用本地仓库。

docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 dockerregistry v2.x 版本。

 

### 安装运行 docker-registry

容器运行

你可以通过获取官方 registry 镜像来运行。

$ docker run -d -p 5000:5000 --restart=always --name registry registry

这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的

/var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例

如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。

$ docker run -d \

-p 5000:5000 \

-v /opt/data/registry:/var/lib/registry \

registry

 

 

### 在私有仓库上传、搜索、下载镜像

创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库。

先在本机查看已有的镜像。

$ docker image ls

REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE

ubuntu              latest              452a96d81c30        2 days ago          79.6MB

hello-world         latest              e38bc07ac18e        2 weeks ago         1.85kB

registry            latest              d1fd7d86a825        3 months ago        33.3MB

使用 docker tag 将 ubuntu:latest 这个镜像标记为 127.0.0.1:5000/ubuntu:latest 。

格式为 docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG] 。

$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest

 

使用 docker push 上传标记的镜像。

$ docker push 127.0.0.1:5000/ubuntu:latest

 

用 curl 查看仓库中的镜像。

$ curl 127.0.0.1:5000/v2/_catalog

 

### Fabric私有仓库

 

\# docker image ls --format "table {{.Repository}}:{{.Tag}}" | grep fabric        

hyperledger/fabric-baseimage:x86_64-0.4.6

hyperledger/fabric-zookeeper:latest

hyperledger/fabric-zookeeper:x86_64-0.4.6

hyperledger/fabric-kafka:latest

hyperledger/fabric-kafka:x86_64-0.4.6

hyperledger/fabric-couchdb:latest

hyperledger/fabric-couchdb:x86_64-0.4.6

hyperledger/fabric-baseos:x86_64-0.4.6

hyperledger/fabric-ca:1.0.5

hyperledger/fabric-ca:x86_64-1.0.5

hyperledger/fabric-kafka:1.0.5

hyperledger/fabric-kafka:x86_64-1.0.4

hyperledger/fabric-zookeeper:1.0.5

hyperledger/fabric-zookeeper:x86_64-1.0.4

hyperledger/fabric-baseimage:x86_64-0.3.2

hyperledger/fabric-baseos:x86_64-0.3.2

 

$ docker tag hyperledger/fabric-baseos:x86_64-0.4.6 192.168.0.117:5000/hyperledger/fabric-baseos:x86_64-0.4.6

$ docker push 192.168.0.117:5000/hyperledger/fabric-baseos:x86_64-0.4.6

 

\# docker image ls --format "table docker tag {{.Repository}}:{{.Tag}} 192.168.0.117:5000/{{.Repository}}:{{.Tag}}" | grep fabric

docker tag hyperledger/fabric-baseimage:x86_64-0.4.6 192.168.0.117:5000/hyperledger/fabric-baseimage:x86_64-0.4.6

docker tag hyperledger/fabric-zookeeper:latest 192.168.0.117:5000/hyperledger/fabric-zookeeper:latest

docker tag hyperledger/fabric-zookeeper:x86_64-0.4.6 192.168.0.117:5000/hyperledger/fabric-zookeeper:x86_64-0.4.6

docker tag hyperledger/fabric-kafka:latest 192.168.0.117:5000/hyperledger/fabric-kafka:latest

docker tag hyperledger/fabric-kafka:x86_64-0.4.6 192.168.0.117:5000/hyperledger/fabric-kafka:x86_64-0.4.6

docker tag hyperledger/fabric-couchdb:latest 192.168.0.117:5000/hyperledger/fabric-couchdb:latest

docker tag hyperledger/fabric-couchdb:x86_64-0.4.6 192.168.0.117:5000/hyperledger/fabric-couchdb:x86_64-0.4.6

docker tag hyperledger/fabric-baseos:x86_64-0.4.6 192.168.0.117:5000/hyperledger/fabric-baseos:x86_64-0.4.6

docker tag hyperledger/fabric-ca:1.0.5 192.168.0.117:5000/hyperledger/fabric-ca:1.0.5

docker tag hyperledger/fabric-ca:x86_64-1.0.5 192.168.0.117:5000/hyperledger/fabric-ca:x86_64-1.0.5

docker tag hyperledger/fabric-kafka:1.0.5 192.168.0.117:5000/hyperledger/fabric-kafka:1.0.5

docker tag hyperledger/fabric-kafka:x86_64-1.0.4 192.168.0.117:5000/hyperledger/fabric-kafka:x86_64-1.0.4

docker tag hyperledger/fabric-zookeeper:1.0.5 192.168.0.117:5000/hyperledger/fabric-zookeeper:1.0.5

docker tag hyperledger/fabric-zookeeper:x86_64-1.0.4 192.168.0.117:5000/hyperledger/fabric-zookeeper:x86_64-1.0.4

docker tag hyperledger/fabric-baseimage:x86_64-0.3.2 192.168.0.117:5000/hyperledger/fabric-baseimage:x86_64-0.3.2

docker tag hyperledger/fabric-baseos:x86_64-0.3.2 192.168.0.117:5000/hyperledger/fabric-baseos:x86_64-0.3.2

 

 

\# docker image ls --format "table docker push 192.168.0.117:5000/{{.Repository}}:{{.Tag}}" | grep fabric

docker push 192.168.0.117:5000/hyperledger/fabric-baseimage:x86_64-0.4.6

docker push 192.168.0.117:5000/hyperledger/fabric-zookeeper:latest

docker push 192.168.0.117:5000/hyperledger/fabric-zookeeper:x86_64-0.4.6

docker push 192.168.0.117:5000/hyperledger/fabric-kafka:latest

docker push 192.168.0.117:5000/hyperledger/fabric-kafka:x86_64-0.4.6

docker push 192.168.0.117:5000/hyperledger/fabric-couchdb:latest

docker push 192.168.0.117:5000/hyperledger/fabric-couchdb:x86_64-0.4.6

docker push 192.168.0.117:5000/hyperledger/fabric-baseos:x86_64-0.4.6

docker push 192.168.0.117:5000/hyperledger/fabric-ca:1.0.5

docker push 192.168.0.117:5000/hyperledger/fabric-ca:x86_64-1.0.5

docker push 192.168.0.117:5000/hyperledger/fabric-kafka:1.0.5

docker push 192.168.0.117:5000/hyperledger/fabric-kafka:x86_64-1.0.4

docker push 192.168.0.117:5000/hyperledger/fabric-zookeeper:1.0.5

docker push 192.168.0.117:5000/hyperledger/fabric-zookeeper:x86_64-1.0.4

docker push 192.168.0.117:5000/hyperledger/fabric-baseimage:x86_64-0.3.2

docker push 192.168.0.117:5000/hyperledger/fabric-baseos:x86_64-0.3.2

 

 

用 curl 查看仓库中的镜像。

$ curl 192.168.0.117:5000/v2/_catalog

 

 

## 私有仓库高级配置

 

### 准备站点证书

这里假设我们将要搭建的私有仓库地址为 docker.domain.com ，下面我们介绍使用 openssl自行签发 docker.domain.com 的站点 SSL 证书。

 

第一步创建 CA 私钥。

$ openssl genrsa -out "root-ca.key" 4096

 

第二步利用私钥创建 CA 根证书请求文件。

$ openssl req \

-new -key "root-ca.key" \

-out "root-ca.csr" -sha256 \

-subj '/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=Your Company Name Doc

ker Registry CA'

以上命令中 -subj 参数里的 /C 表示国家，如 CN ； /ST 表示省； /L 表示城市或者

地区； /O 表示组织名； /CN 通用名称。

 

第三步配置 CA 根证书，新建 root-ca.cnf 。

[root_ca]

basicConstraints = critical,CA:TRUE,pathlen:1

keyUsage = critical, nonRepudiation, cRLSign, keyCertSign

subjectKeyIdentifier=hash

 

第四步签发根证书。

$ openssl x509 -req -days 3650 -in "root-ca.csr" \

-signkey "root-ca.key" -sha256 -out "root-ca.crt" \

-extfile "root-ca.cnf" -extensions \

root_ca

 

第五步生成站点 SSL 私钥。

$ openssl genrsa -out "docker.domain.com.key" 4096

 

第六步使用私钥生成证书请求文件。

$ openssl req -new -key "docker.domain.com.key" -out "site.csr" -sha256 \

-subj '/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=docker.domain.com'

 

第七步配置证书，新建 site.cnf 文件。

[server]

authorityKeyIdentifier=keyid,issuer

basicConstraints = critical,CA:FALSE

extendedKeyUsage=serverAuth

keyUsage = critical, digitalSignature, keyEncipherment

subjectAltName = DNS:docker.domain.com, IP:127.0.0.1

subjectKeyIdentifier=hash

 

第八步签署站点 SSL 证书。

$ openssl x509 -req -days 750 -in "site.csr" -sha256 \

-CA "root-ca.crt" -CAkey "root-ca.key" -CAcreateserial \

-out "docker.domain.com.crt" -extfile "site.cnf" -extensions server

这样已经拥有了 docker.domain.com 的网站 SSL 私钥 docker.domain.com.key 和 SSL 证书

docker.domain.com.crt 。

 

新建 ssl 文件夹并将 docker.domain.com.key docker.domain.com.crt 这两个文件移入，删除其他文件。

 

 

### 配置私有仓库

私有仓库默认的配置文件位于 /etc/docker/registry/config.yml ，我们先在本地编辑config.yml ，之后挂载到容器中。

version: 0.1

log:

accesslog:

disabled: true

level: debug

formatter: text

fields:

service: registry

environment: staging

storage:

delete:

enabled: true

cache:

blobdescriptor: inmemory

filesystem:

rootdirectory: /var/lib/registry

auth:

htpasswd:

realm: basic-realm

path: /etc/docker/registry/auth/nginx.htpasswd

http:

addr: :443

host: https://docker.domain.com

headers:

X-Content-Type-Options: [nosniff]

http2:

disabled: false

tls:

certificate: /etc/docker/registry/ssl/docker.domain.com.crt

key: /etc/docker/registry/ssl/docker.domain.com.key

health:

storagedriver:

enabled: true

interval: 10s

threshold: 3

 

### 生成 http 认证文件

$ mkdir auth

$ docker run --rm \

--entrypoint htpasswd \

registry \

-Bbn username password > auth/nginx.htpasswd

将上面的 username password 替换为你自己的用户名和密码。

 

### 编辑 docker-compose.yml

version: '3'

services:

registry:

image: registry

ports:

\- "443:443"

volumes:

\- ./:/etc/docker/registry

\- registry-data:/var/lib/registry

volumes:

registry-data:

 

 

### 修改 hosts

编辑 /etc/hosts

docker.domain.com 127.0.0.1

### 启动

$ docker-compose up -d

这样我们就搭建好了一个具有权限认证、TLS 的私有仓库，接下来我们测试其功能是否正

常。

 

### 测试私有仓库功能

登录到私有仓库。

$ docker login docker.domain.com

尝试推送、拉取镜像。

 

$ docker pull ubuntu:17.10

$ docker tag ubuntu:17.10 docker.domain.com/username/ubuntu:17.10

$ docker push docker.domain.com/username/ubuntu:17.10

$ docker image rm docker.domain.com/username/ubuntu:17.10

$ docker pull docker.domain.com/username/ubuntu:17.10

 

如果我们退出登录，尝试推送镜像。

$ docker logout docker.domain.com

$ docker push docker.domain.com/username/ubuntu:17.10

no basic auth credentials

发现会提示没有登录，不能将镜像推送到私有仓库中。

 

# Docker 数据管理

 

如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：

数据卷（Volumes）

挂载主机目录 (Bind mounts)

 

 

## 数据卷

数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：

- 数据卷 可以在容器之间共享和重用
- 对 数据卷 的修改会立马生效
- 对 数据卷 的更新，不会影响镜像
- 数据卷 默认会一直存在，即使容器被删除

注意： 数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂
载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷 。

 

选择 -v 还是 -–mount 参数

Docker 新用户应该选择 --mount 参数，经验丰富的 Docker 使用者对 -v 或者 --volume

已经很熟悉了，但是推荐使用 --mount 参数。

### 创建一个数据卷

$ docker volume create my-vol

 

查看所有的 数据卷

$ docker volume ls

DRIVER              VOLUME NAME

local               my-vol

在主机里使用以下命令可以查看指定 数据卷 的信息

 

 

### 启动一个挂载数据卷的容器

在用 docker run 命令的时候，使用 --mount 标记来将 数据卷 挂载到容器里。在一次
docker run 中可以挂载多个 数据卷 。
下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。
$ docker run -d -P \

--name web \

\# -v my-vol:/wepapp \

--mount source=my-vol,target=/webapp \

training/webapp \

python app.py

 

 

### 查看数据卷的具体信息

在主机里使用以下命令可以查看 web 容器的信息

$ docker inspect web

 

数据卷 信息在 "Mounts" Key 下面

 

"Mounts": [

​            {

​                "Type": "volume",

​                "Name": "my-vol",

​                "Source": "/var/lib/docker/volumes/my-vol/_data",

​                "Destination": "/webapp",

​                "Driver": "local",

​                "Mode": "z",

​                "RW": true,

​                "Propagation": ""

​            }

​        ],

 

### 删除数据卷

$ docker volume rm my-vol

数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷 ，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷 。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。

无主的数据卷可能会占据很多空间，要清理请使用以下命令

$ docker volume prune

 

 

## 挂载主机目录

选择 -v 还是 -–mount 参数

Docker 新用户应该选择 --mount 参数，经验丰富的 Docker 使用者对 -v 或者 --volume

已经很熟悉了，但是推荐使用 --mount 参数。

 

### 挂载一个主机目录作为数据卷

使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。

$ docker run -d -P \

--name web \

\# -v /src/webapp:/opt/webapp \

--mount type=bind,source=/src/webapp,target=/opt/webapp \

training/webapp \

python app.py

上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 --mount 参数时如果本地目录不存在，Docker 会报错。

Docker 挂载主机目录的默认权限是 读写 ，用户也可以通过增加 readonly 指定为 只读 。

 

### 查看数据卷的具体信息

在主机里使用以下命令可以查看 web 容器的信息
监听主机目录

$ docker inspect web

 

 

### 挂载一个本地主机文件作为数据卷

--mount 标记也可以从主机挂载单个文件到容器中
$ docker run --rm -it \

\# -v $HOME/.bash_history:/root/.bash_history \

--mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \

ubuntu:16.04 \

bash

 

 

# Docker 中的网络功能介绍

Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。

 

## 外部访问容器

容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。

当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。

使用 docker container ls 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。

$ docker run -d -P training/webapp python app.py

$ docker container ls -l

CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS  NAMES
bc533791f3f5 training/webapp:latest python app.py 5 seconds ago Up 2 seconds 0.0.0.0:49155->5000/tcp nostalgic_morse

 

 

### 映射所有接口地址

使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口，可以执行
$ docker run -d -p 5000:5000 training/webapp python app.py

此时默认会绑定本地所有接口上的所有地址。

 

 

### 映射到指定地址的指定端口

可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址127.0.0.1
$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py

 

 

 

# 高级网络配置

 

当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。

同时，Docker 随机分配一个本地未占用的私有网段（在 [RFC1918](http://tools.ietf.org/html/rfc1918) 中定义）中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。

当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。

 ![](C:\Users\dell\Desktop\docke网络配置.png)

 

## 快速配置指南

下面是一个跟 Docker 网络相关的命令列表。

其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。

- -b BRIDGE或 --bridge=BRIDGE 指定容器挂载的网桥
- --bip=CIDR定制 docker0 的掩码
- -H SOCKET...或 --host=SOCKET... Docker 服务端接收命令的通道
- --icc=true|false是否支持容器之间进行通信
- --ip-forward=true|false请看下文容器之间的通信
- --iptables=true|false是否允许 Docker 添加 iptables 规则
- --mtu=BYTES容器网络中的 MTU

下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 docker run 时可以覆盖设置的默认值。

- --dns=IP_ADDRESS...使用指定的DNS服务器
- --dns-search=DOMAIN...指定DNS搜索域

最后这些选项只有在 docker run 执行时使用，因为它是针对容器的特性内容。

- -h HOSTNAME或 --hostname=HOSTNAME 配置容器主机名
- --link=CONTAINER_NAME:ALIAS添加到另一个容器的连接
- --net=bridge|none|container:NAME_or_ID|host配置容器的桥接模式
- -p SPEC或 --publish=SPEC 映射容器端口到宿主主机
- -P or --publish-all=true|false映射容器所有端口到宿主主机

 

 

## 容器访问控制

容器的访问控制，主要通过 Linux 上的 iptables 防火墙来进行管理和实现。iptables 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。

### 容器访问外部网络

容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。

$sysctl net.ipv4.ip_forwardnet.ipv4.ip_forward = 1

如果为 0，说明没有开启转发，则需要手动打开。

$sysctl -w net.ipv4.ip_forward=1

如果在启动 Docker 服务的时候设定 --ip-forward=true, Docker 就会自动设定系统的 ip_forward 参数为 1。

### 容器之间访问

容器之间相互访问，需要两方面的支持。

- 容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到docker0 网桥上。
- 本地系统的防火墙软件 -- iptables是否允许通过。

#### 访问所有端口

当启动 Docker 服务时候，默认会添加一条转发策略到 iptables 的 FORWARD 链上。策略为通过（ACCEPT）还是禁止（DROP）取决于配置--icc=true（缺省值）还是 --icc=false。当然，如果手动指定 --iptables=false 则不会添加 iptables 规则。

可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 /etc/default/docker 文件中配置 DOCKER_OPTS=--icc=false 来禁止它。

#### 访问指定端口

在通过 -icc=false 关闭网络访问后，还可以通过 --link=CONTAINER_NAME:ALIAS 选项来访问容器的开放端口。

例如，在启动 Docker 服务时，可以同时使用 icc=false --iptables=true 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 iptables 规则。

此时，系统中的 iptables 规则可能是类似

$ sudo iptables -nL...Chain FORWARD (policy ACCEPT)target     prot opt source               destinationDROP       all  --  0.0.0.0/0            0.0.0.0/0...

之后，启动容器（docker run）时使用 --link=CONTAINER_NAME:ALIAS 选项。Docker 会在 iptable 中为 两个容器分别添加一条 ACCEPT 规则，允许相互访问开放的端口（取决于 Dockerfile 中的 EXPOSE 指令）。

当添加了 --link=CONTAINER_NAME:ALIAS 选项后，添加了 iptables 规则。

$ sudo iptables -nL...Chain FORWARD (policy ACCEPT)target     prot opt source               destinationACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80ACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80DROP       all  --  0.0.0.0/0            0.0.0.0/0

注意：--link=CONTAINER_NAME:ALIAS 中的 CONTAINER_NAME 目前必须是 Docker 分配的名字，或使用 --name 参数指定的名字。主机名则不会被识别。

 

 

## 映射容器端口到宿主主机的实现

默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。

### 容器访问外部实现

容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 iptables 的源地址伪装操作实现的。

查看主机的 NAT 规则。

$ sudo iptables -t nat -nL...Chain POSTROUTING (policy ACCEPT)target     prot opt source               destinationMASQUERADE  all  --  172.17.0.0/16       !172.17.0.0/16...

其中，上述规则将所有源地址在 172.17.0.0/16 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。

### 外部访问容器实现

容器允许外部访问，可以在 docker run 时候通过 -p 或 -P 参数来启用。

不管用那种办法，其实也是在本地的 iptable 的 nat 表中添加相应的规则。

使用 -P 时：

$ iptables -t nat -nL...Chain DOCKER (2 references)target     prot opt source               destinationDNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:49153 to:172.17.0.2:80

使用 -p 80:80 时：

$ iptables -t nat -nLChain DOCKER (2 references)target     prot opt source               destinationDNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80

注意：

- 这里的规则映射了0.0.0，意味着将接受主机来自所有接口的流量。用户可以通过 -p IP:host_port:container_port 或 -p IP::port 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。
- 如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件/etc/docker/daemon.json 中添加如下内容。

{  "ip": "0.0.0.0"}

 

 

## 配置 docker0 网桥

Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。

Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。

- --bip=CIDRIP 地址加掩码格式，例如168.1.5/24
- --mtu=BYTES覆盖默认的 Docker mtu 配置

也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。

由于目前 Docker 网桥是 Linux 网桥，用户可以使用 brctl show 来查看网桥和端口连接信息。

$ sudo brctl show

bridge name     bridge id               STP enabled     interfaces

docker0         8000.3a1d7362b4ee       no              veth65f9

​                                             vethdda6

*注：brctl 命令在 Debian、Ubuntu 中可以使用 sudo apt-get install bridge-utils 来安装。

每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 docker0 接口的 IP 作为所有容器的默认网关。

$ sudo docker run -i -t --rm base /bin/bash

$ ip addr show eth0

24: eth0: <BROADCAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000

​    link/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff

​    inet 172.17.0.3/16 scope global eth0

​       valid_lft forever preferred_lft forever

​    inet6 fe80::306f:e0ff:fe35:5791/64 scope link

​       valid_lft forever preferred_lft forever

$ ip route

default via 172.17.42.1 dev eth0

172.17.0.0/16 dev eth0  proto kernel  scope link  src 172.17.0.3

 

 

## 自定义网桥

除了默认的 docker0 网桥，用户也可以指定网桥来连接各个容器。

在启动 Docker 服务的时候，使用 -b BRIDGE或--bridge=BRIDGE 来指定使用的网桥。

如果服务已经运行，那需要先停止服务，并删除旧的网桥。

$ sudo systemctl stop docker

$ sudo ip link set dev docker0 down

$ sudo brctl delbr docker0

然后创建一个网桥 bridge0。

$ sudo brctl addbr bridge0

$ sudo ip addr add 192.168.5.1/24 dev bridge0

$ sudo ip link set dev bridge0 up

查看确认网桥创建并启动。

$ ip addr show bridge0

4: bridge0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state UP group default

​    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff

​    inet 192.168.5.1/24 scope global bridge0

​       valid_lft forever preferred_lft forever

在 Docker 配置文件 /etc/docker/daemon.json 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。

{

  "bridge": "bridge0",

}

启动 Docker 服务。

新建一个容器，可以看到它已经桥接到了 bridge0 上。

可以继续用 brctl show 命令查看桥接的信息。另外，在容器中可以使用 ip addr 和 ip route 命令来查看 IP 地址配置和路由信息。

 

 

## 工具和示例

### pipework

Jérôme Petazzoni 编写了一个叫 [pipework](https://github.com/jpetazzo/pipework) 的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。

### playground

Brandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 [Python库](https://github.com/brandon-rhodes/fopnp/tree/m/playground)，包括路由、NAT 防火墙；以及一些提供 HTTP, SMTP, POP, IMAP, Telnet, SSH, FTP 的服务器。

 

 

## 编辑网络配置文件

Docker 1.2.0 开始支持在运行中的容器里编辑 /etc/hosts, /etc/hostname 和 /etc/resolve.conf 文件。

但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来。也不会被 docker commit 提交。

 

 

 

## 示例：创建一个点到点连接

默认情况下，Docker 会将所有容器连接到由 docker0 提供的虚拟子网中。

用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。

解决办法很简单：创建一对 peer 接口，分别放到两个容器中，配置成点到点链路类型即可。

首先启动 2 个容器：

$ docker run -i -t --rm --net=none base /bin/bash

root@1f1f4c1f931a:/#

$ docker run -i -t --rm --net=none base /bin/bash

root@12e343489d2f:/#

找到进程号，然后创建网络命名空间的跟踪文件。

$ docker inspect -f '{{.State.Pid}}' 1f1f4c1f931a

2989

$ docker inspect -f '{{.State.Pid}}' 12e343489d2f

3004

$ sudo mkdir -p /var/run/netns

$ sudo ln -s /proc/2989/ns/net /var/run/netns/2989

$ sudo ln -s /proc/3004/ns/net /var/run/netns/3004

创建一对 peer 接口，然后配置路由

$ sudo ip link add A type veth peer name B

 

$ sudo ip link set A netns 2989

$ sudo ip netns exec 2989 ip addr add 10.1.1.1/32 dev A

$ sudo ip netns exec 2989 ip link set A up

$ sudo ip netns exec 2989 ip route add 10.1.1.2/32 dev A

 

$ sudo ip link set B netns 3004

$ sudo ip netns exec 3004 ip addr add 10.1.1.2/32 dev B

$ sudo ip netns exec 3004 ip link set B up

$ sudo ip netns exec 3004 ip route add 10.1.1.1/32 dev B

现在这 2 个容器就可以相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。

此外，也可以不指定 --net=none 来创建点到点链路。这样容器还可以通过原先的网络来通信。

利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 --icc=false 来关闭容器之间的通信。

 

 

 

# Docker Compose 项目

 

## Compose 简介

 

Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。

 

通过一个单独的 docker-compose.yml 模板文件

（YAML 格式） 来定义一组相关联的应用容器为一个项目（project） 。

 

Compose 中有两个重要的概念：

服务 ( service )：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。

项目 ( project )：由一组关联的应用容器组成的一个完整业务单元，在 dockercompose.yml 文件中定义。

Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。

 

Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。

 

 

## 安装与卸载

 

### 二进制包

在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。

例如，在 Linux 64 位系统上直接下载对应的二进制包。

$ sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose

$ sudo chmod +x /usr/local/bin/docker-compose

 

也可直接按下面执行

$ sudo curl -L https://github.com/docker/compose/releases/download/1.21.1/docker-compose-Linux-x86_64 > /usr/local/bin/docker-compose

$ sudo chmod +x /usr/local/bin/docker-compose

 

### 容器中执行

Compose 既然是一个 Python 应用，自然也可以直接用容器来执行它。

$ curl -L https://github.com/docker/compose/releases/download/1.21.1/run.sh > /usr/local/bin/docker-compose

$ chmod +x /usr/local/bin/docker-compose

实际上，查看下载的 run.sh 脚本内容

 

可以看到，它其实是下载了 docker/compose 镜像并运行。

 

### 卸载

如果是二进制包方式安装的，删除二进制文件即可。

$ sudo rm /usr/local/bin/docker-compose

 

 

 

 

## 使用

 

### 术语

首先介绍几个术语。

服务 ( service )：一个应用容器，实际上可以运行多个相同镜像的实例。

项目 ( project )：由一组关联的应用容器组成的一个完整业务单元。

可见，一个项目可以由多个服务（容器） 关联而成， Compose 面向项目进行管理。

 

### 场景

最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。

下面我们用 Python 来建立一个能够记录页面访问次数的 web 网站。

 

### web 应用

新建文件夹，在该目录中编写 app.py 文件
from flask import Flask

from redis import Redis

 

app = Flask(__name__)

redis = Redis(host='redis', port=6379)

 

@app.route('/')
def hello():

count = redis.incr('hits')

return 'Hello World! 该页面已被访问 {} 次。\n'.format(count)

 

if __name__ == "__main__":

app.run(host="0.0.0.0", debug=True)

 

### Dockerfile

编写 Dockerfile 文件，内容为

FROM python:3.6-alpine

ADD . /code

WORKDIR /code

RUN pip install redis flask

CMD ["python", "app.py"]

 

 

### docker-compose.yml

编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。

 

version: '3'

services:

 

web:

build: .

ports:

\- "5000:5000"

 

redis:

image: "redis:alpine"

 

### 运行 compose 项目

$ docker-compose up

 

 

## Compose 命令说明

 

root@ubuntu16:~# docker-compose --help

Define and run multi-container applications with Docker.

 

Usage:

  docker-compose [-f <arg>...] [options] [COMMAND] [ARGS...]

  docker-compose -h|--help

 

Options:

  -f, --file FILE             Specify an alternate compose file (default: docker-compose.yml)

  -p, --project-name NAME     Specify an alternate project name (default: directory name)

  --verbose                   Show more output

  --no-ansi                   Do not print ANSI control characters

  -v, --version               Print version and exit

  -H, --host HOST             Daemon socket to connect to

 

  --tls                       Use TLS; implied by --tlsverify

  --tlscacert CA_PATH         Trust certs signed only by this CA

  --tlscert CLIENT_CERT_PATH  Path to TLS certificate file

  --tlskey TLS_KEY_PATH       Path to TLS key file

  --tlsverify                 Use TLS and verify the remote

  --skip-hostname-check       Don't check the daemon's hostname against the name specified

​                              in the client certificate (for example if your docker host

​                              is an IP address)

  --project-directory PATH    Specify an alternate working directory

​                              (default: the path of the Compose file)

 

Commands:

  build              Build or rebuild services

  bundle             Generate a Docker bundle from the Compose file

  config             Validate and view the Compose file

  create             Create services

  down               Stop and remove containers, networks, images, and volumes

  events             Receive real time events from containers

  exec               Execute a command in a running container

  help               Get help on a command

  images             List images

  kill               Kill containers

  logs               View output from containers

  pause              Pause services

  port               Print the public port for a port binding

  ps                 List containers

  pull               Pull service images

  push               Push service images

  restart            Restart services

  rm                 Remove stopped containers

  run                Run a one-off command

  scale              Set number of containers for a service

  start              Start services

  stop               Stop services

  top                Display the running processes

  unpause            Unpause services

  up                 Create and start containers

  version            Show the Docker-Compose version information

 

 

### 命令对象与格式

对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。

执行 docker-compose [COMMAND] --help 或者 docker-compose help [COMMAND] 可以查看具体某个命令的使用格式。

docker-compose 命令的基本的使用格式是

docker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]

### 命令选项

- -f, --file FILE指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。
- -p, --project-name NAME指定项目名称，默认将使用所在目录名称作为项目名。
- --x-networking使用 Docker 的可拔插网络后端特性
- --x-network-driver DRIVER指定网络后端的驱动，默认为 bridge
- --verbose输出更多调试信息。
- -v, --version打印版本并退出。

### 命令使用说明

**build**

格式为 docker-compose build [options] [SERVICE...]。

构建（重新构建）项目中的服务容器。

服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。

可以随时在项目目录下运行 docker-compose build 来重新构建服务。

选项包括：

- --force-rm删除构建过程中的临时容器。
- --no-cache构建镜像过程中不使用 cache（这将加长构建过程）。
- --pull始终尝试通过 pull 来获取更新版本的镜像。

**config**

验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。

**down**

此命令将会停止 up 命令所启动的容器，并移除网络

**exec**

进入指定的容器。

**help**

获得一个命令的帮助。

**images**

列出 Compose 文件中包含的镜像。

**kill**

格式为 docker-compose kill [options] [SERVICE...]。

通过发送 SIGKILL 信号来强制停止服务容器。

支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。

$ docker-compose kill -s SIGINT

**logs**

格式为 docker-compose logs [options] [SERVICE...]。

查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 --no-color 来关闭颜色。

该命令在调试问题的时候十分有用。

**pause**

格式为 docker-compose pause [SERVICE...]。

暂停一个服务容器。

**port**

格式为 docker-compose port [options] SERVICE PRIVATE_PORT。

打印某个容器端口所映射的公共端口。

选项：

- --protocol=proto指定端口协议，tcp（默认值）或者 udp。
- --index=index如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。

**ps**

格式为 docker-compose ps [options] [SERVICE...]。

列出项目中目前的所有容器。

选项：

- -q只打印容器的 ID 信息。

**pull**

格式为 docker-compose pull [options] [SERVICE...]。

拉取服务依赖的镜像。

选项：

- --ignore-pull-failures忽略拉取镜像过程中的错误。

**push**

推送服务依赖的镜像到 Docker 镜像仓库。

**restart**

格式为 docker-compose restart [options] [SERVICE...]。

重启项目中的服务。

选项：

- -t, --timeout TIMEOUT指定重启前停止容器的超时（默认为 10 秒）。

**rm**

格式为 docker-compose rm [options] [SERVICE...]。

删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。

选项：

- -f, --force强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。
- -v删除容器所挂载的数据卷。

**run**

格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]。

在指定服务上执行一个命令。

例如：

$ docker-compose run ubuntu ping docker.com

将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。

默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。

该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。

两个不同点：

- 给定命令将会覆盖原有的自动运行命令；
- 不会自动创建端口，以避免冲突。

如果不希望自动启动关联的容器，可以使用 --no-deps 选项，例如

$ docker-compose run --no-deps web python manage.py shell

将不会启动 web 容器所关联的其它容器。

选项：

- -d后台运行容器。
- --name NAME为容器指定一个名字。
- --entrypoint CMD覆盖默认的容器启动指令。
- -e KEY=VAL设置环境变量值，可多次使用选项来设置多个环境变量。
- -u, --user=""指定运行容器的用户名或者 uid。
- --no-deps不自动启动关联的服务容器。
- --rm运行命令后自动删除容器，d 模式下将忽略。
- -p, --publish=[]映射容器端口到本地主机。
- --service-ports配置服务端口并映射到本地主机。
- -T不分配伪 tty，意味着依赖 tty 的指令将无法运行。

**scale**

格式为 docker-compose scale [options] [SERVICE=NUM...]。

设置指定服务运行的容器个数。

通过 service=num 的参数来设置数量。例如：

$ docker-compose scale web=3 db=2

将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。

一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。

选项：

- -t, --timeout TIMEOUT停止容器时候的超时（默认为 10 秒）。

**start**

格式为 docker-compose start [SERVICE...]。

启动已经存在的服务容器。

**stop**

格式为 docker-compose stop [options] [SERVICE...]。

停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。

选项：

- -t, --timeout TIMEOUT停止容器时候的超时（默认为 10 秒）。

**top**

查看各个服务容器内运行的进程。

**unpause**

格式为 docker-compose unpause [SERVICE...]。

恢复处于暂停状态中的服务。

**up**

格式为 docker-compose up [options] [SERVICE...]。

该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。

链接的服务都将会被自动启动，除非已经处于运行状态。

可以说，大部分时候都可以直接通过该命令来启动一个项目。

默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。

当通过 Ctrl-C 停止命令时，所有容器将会停止。

如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。

默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up --no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d <SERVICE_NAME> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。

选项：

- -d在后台运行服务容器。
- --no-color不使用颜色来区分不同的服务的控制台输出。
- --no-deps不启动服务所链接的容器。
- --force-recreate强制重新创建容器，不能与 --no-recreate 同时使用。
- --no-recreate如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。
- --no-build不自动构建缺失的服务镜像。
- -t, --timeout TIMEOUT停止容器时候的超时（默认为 10 秒）。

**version**

格式为 docker-compose version。

打印版本信息。

 

 

 

## Compose 模板文件

 

默认的模板文件名称为 docker-compose.yml ，格式为 YAML 格式。

 

version: "3"

 

services:

webapp:

image: examples/web

ports:

\- "80:80"

 

volumes:

\- "/data"

 

 

各个指令的用法。

**build**

指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。

version: '3'services:   webapp:    build: ./dir

你也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。

使用 dockerfile 指令指定 Dockerfile 文件名。

使用 arg 指令指定构建镜像时的变量。

version: '3'services:   webapp:    build:      context: ./dir      dockerfile: Dockerfile-alternate      args:        buildno: 1

使用 cache_from 指定构建镜像的缓存

build:  context: .  cache_from:    - alpine:latest    - corp/web_app:3.14

**cap_add, cap_drop**

指定容器的内核能力（capacity）分配。

例如，让容器拥有所有能力可以指定为：

cap_add:  - ALL

去掉 NET_ADMIN 能力可以指定为：

cap_drop:  - NET_ADMIN

**command**

覆盖容器启动后默认执行的命令。

command: echo "hello world"

**configs**

仅用于 Swarm mode，详细内容请查看 [Swarm mode](https://docker_practice.gitee.io/swarm_mode) 一节。

**cgroup_parent**

指定父 cgroup 组，意味着将继承该组的资源限制。

例如，创建了一个 cgroup 组名称为 cgroups_1。

cgroup_parent: cgroups_1

**container_name**

指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。

container_name: docker-web-container

注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。

**deploy**

仅用于 Swarm mode，详细内容请查看 [Swarm mode](https://docker_practice.gitee.io/swarm_mode) 一节

**devices**

指定设备映射关系。

devices:  - "/dev/ttyUSB1:/dev/ttyUSB0"

**depends_on**

解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web

version: '3' services:  web:    build: .    depends_on:      - db      - redis   redis:    image: redis   db:    image: postgres

注意：web 服务不会等待 redis db 「完全启动」之后才启动。

**dns**

自定义 DNS 服务器。可以是一个值，也可以是一个列表。

dns: 8.8.8.8 dns:  - 8.8.8.8  - 114.114.114.114

**dns_search**

配置 DNS 搜索域。可以是一个值，也可以是一个列表。

dns_search: example.com dns_search:  - domain1.example.com  - domain2.example.com

**tmpfs**

挂载一个 tmpfs 文件系统到容器。

tmpfs: /runtmpfs:  - /run  - /tmp

**env_file**

从文件中获取环境变量，可以为单独的文件路径或列表。

如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。

如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。

env_file: .env env_file:  - ./common.env  - ./apps/web.env  - /opt/secrets.env

环境变量文件中每一行必须符合格式，支持 # 开头的注释行。

\# common.env: Set development environmentPROG_ENV=development

**environment**

设置环境变量。你可以使用数组或字典两种格式。

只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。

environment:  RACK_ENV: development  SESSION_SECRET: environment:  - RACK_ENV=development  - SESSION_SECRET

如果变量名称或者值中用到 true|false，yes|no 等表达 [布尔](http://yaml.org/type/bool.html) 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括

y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF

**expose**

暴露端口，但不映射到宿主机，只被连接的服务访问。

仅可以指定内部端口为参数

expose: - "3000" - "8000"

**external_links**

注意：不建议使用该指令。

链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器。

external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql

**extra_hosts**

类似 Docker 中的 --add-host 参数，指定额外的 host 名称映射信息。

extra_hosts: - "googledns:8.8.8.8" - "dockerhub:52.1.157.61"

会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。

8.8.8.8 googledns52.1.157.61 dockerhub

**healthcheck**

通过命令检查容器是否健康运行。

healthcheck:  test: ["CMD", "curl", "-f", "http://localhost"]  interval: 1m30s  timeout: 10s  retries: 3

**image**

指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。

image: ubuntuimage: orchardup/postgresqlimage: a4bc65fd

**labels**

为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。

labels:  com.startupteam.description: "webapp for a startup team"  com.startupteam.department: "devops department"  com.startupteam.release: "rc3 for v1.0"

**links**

注意：不推荐使用该指令。

**logging**

配置日志选项。

logging:  driver: syslog  options:    syslog-address: "tcp://192.168.0.42:123"

目前支持三种日志驱动类型。

driver: "json-file"driver: "syslog"driver: "none"

options 配置日志驱动的相关参数。

options:  max-size: "200k"  max-file: "10"

**network_mode**

设置网络模式。使用和 docker run 的 --network 参数一样的值。

network_mode: "bridge"network_mode: "host"network_mode: "none"network_mode: "service:[service name]"network_mode: "container:[container name/id]"

**networks**

配置容器连接的网络。

version: "3"services:   some-service:    networks:     - some-network     - other-network networks:  some-network:  other-network:

**pid**

跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。

pid: "host"

**ports**

暴露端口信息。

使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。

ports: - "3000" - "8000:8000" - "49100:22" - "127.0.0.1:8001:8001"

*注意：当使用* *HOST:CONTAINER* *格式来映射端口时，如果你使用的容器端口小于* *60* *并且没放到引号里，可能会得到错误结果，因为* *YAML* *会自动解析* *xx:yy* *这种数字格式为* *60* *进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。*

**secrets**

存储敏感数据，例如 mysql 服务密码。

version: "3.1"services: mysql:  image: mysql  environment:    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password  secrets:    - db_root_password    - my_other_secret secrets:  my_secret:    file: ./my_secret.txt  my_other_secret:    external: true

**security_opt**

指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。

security_opt:    - label:user:USER    - label:role:ROLE

**stop_signal**

设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。

stop_signal: SIGUSR1

**sysctls**

配置容器内核参数。

sysctls:  net.core.somaxconn: 1024  net.ipv4.tcp_syncookies: 0 sysctls:  - net.core.somaxconn=1024  - net.ipv4.tcp_syncookies=0

**ulimits**

指定容器的 ulimits 限制值。

例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。

  ulimits:    nproc: 65535    nofile:      soft: 20000      hard: 40000

**volumes**

数据卷所挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。

该指令中路径支持相对路径。

volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro

**其它指令**

此外，还有包括 domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir 等指令，基本跟 docker run 中对应参数的功能一致。

指定服务容器启动后执行的入口文件。

entrypoint: /code/entrypoint.sh

指定容器中运行应用的用户名。

user: nginx

指定容器中工作目录。

working_dir: /code

指定容器中搜索域名、主机名、mac 地址等。

domainname: your_website.comhostname: testmac_address: 08-00-27-00-0C-0A

允许容器中运行一些特权命令。

privileged: true

指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。

restart: always

以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。

read_only: true

打开标准输入，可以接受外部输入。

stdin_open: true

模拟一个伪终端。

tty: true

**读取变量**

Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。

例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。

version: "3"services: db:  image: "mongo:${MONGO_VERSION}"

如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。

若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。

在当前目录新建 .env 文件并写入以下内容。

\# 支持 # 号注释MONGO_VERSION=3.6

执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。

 

 

# Docker Machine 项目

![](C:\Users\dell\Desktop\docke Machine.png)

Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境。

Docker Machine 项目基于 Go 语言实现，目前在 [Github](https://github.com/docker/machine) 上进行维护。

 

## 安装

Docker Machine 可以在多种操作系统平台上安装，包括 Linux、macOS，以及 Windows。

 

### Linux

在 Linux 上的也安装十分简单，从 [官方 GitHub Release](https://github.com/docker/machine/releases) 处直接下载编译好的二进制文件即可。

例如，在 Linux 64 位系统上直接下载对应的二进制包。

$ sudo curl -L https://github.com/docker/machine/releases/download/v0.14.0/docker-machine-`uname -s`-`uname -m` > /usr/local/bin/docker-machine$ sudo chmod +x /usr/local/bin/docker-machine

完成后，查看版本信息。

$ docker-machine -vdocker-machine version 0.14.0, build [89b8332](https://github.com/docker/machine/commit/89b833253d9412716a0291cbdccc94454c33d1b5)

 

 

## 使用

Docker Machine 支持多种后端驱动，包括虚拟机、本地主机和云平台等。

### 创建本地主机实例

#### Virtualbox 驱动

使用 virtualbox 类型的驱动，创建一台 Docker 主机，命名为 test。

$ docker-machine create -d virtualbox test

你也可以在创建时加上如下参数，来配置主机或者主机上的 Docker。

--engine-opt dns=114.114.114.114 配置 Docker 的默认 DNS

--engine-registry-mirror https://registry.docker-cn.com 配置 Docker 的仓库镜像

--virtualbox-memory 2048 配置主机内存

--virtualbox-cpu-count 2 配置主机 CPU

更多参数请使用 docker-machine create --driver virtualbox --help 命令查看。

#### macOS xhyve 驱动

xhyve 驱动 GitHub: <https://github.com/zchee/docker-machine-driver-xhyve>

[xhyve](https://github.com/mist64/xhyve) 是 macOS 上轻量化的虚拟引擎，使用其创建的 Docker Machine 较 VirtualBox 驱动创建的运行效率要高。

$ brew install docker-machine-driver-xhyve $ docker-machine create \      -d xhyve \      # --xhyve-boot2docker-url ~/.docker/machine/cache/boot2docker.iso \      --engine-opt dns=114.114.114.114 \      --engine-registry-mirror https://registry.docker-cn.com \      --xhyve-memory-size 2048 \      --xhyve-rawdisk \      --xhyve-cpu-count 2 \      xhyve

注意：非首次创建时建议加上 --xhyve-boot2docker-url ~/.docker/machine/cache/boot2docker.iso 参数，避免每次创建时都从 GitHub 下载 ISO 镜像。

更多参数请使用 docker-machine create --driver xhyve --help 命令查看。

#### Windows 10

Windows 10 安装 Docker for Windows 之后不能再安装 VirtualBox，也就不能使用 virtualbox 驱动来创建 Docker Machine，我们可以选择使用 hyperv 驱动。

$ docker-machine create --driver hyperv vm

更多参数请使用 docker-machine create --driver hyperv --help 命令查看。

### 使用介绍

创建好主机之后，查看主机

$ docker-machine ls NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER       ERRORStest      -        virtualbox   Running   tcp://192.168.99.187:2376           v17.10.0-ce

创建主机成功后，可以通过 env 命令来让后续操作对象都是目标主机。

$ docker-machine env test

后续根据提示在命令行输入命令之后就可以操作 test 主机。

也可以通过 SSH 登录到主机。

$ docker-machine ssh test docker@test:~$ docker --versionDocker version 17.10.0-ce, build f4ffd25

连接到主机之后你就可以在其上使用 Docker 了。

### 官方支持驱动

通过 -d 选项可以选择支持的驱动类型。

- amazonec2
- azure
- digitalocean
- exoscale
- generic
- google
- hyperv
- none
- openstack
- rackspace
- softlayer
- virtualbox
- vmwarevcloudair
- vmwarefusion
- vmwarevsphere

### 第三方驱动

请到 [第三方驱动列表](https://github.com/docker/docker.github.io/blob/master/machine/AVAILABLE_DRIVER_PLUGINS.md) 查看

### 操作命令

- active查看活跃的 Docker 主机
- config输出连接的配置信息
- create创建一个 Docker 主机
- env显示连接到某个主机需要的环境变量
- inspect输出主机更多信息
- ip获取主机地址
- kill停止某个主机
- ls列出所有管理的主机
- provision重新设置一个已存在的主机
- regenerate-certs为某个主机重新生成 TLS 认证信息
- restart重启主机
- rm删除某台主机
- sshSSH 到主机上执行命令
- scp在主机之间复制文件
- mount挂载主机目录到本地
- start启动一个主机
- status查看主机状态
- stop停止一个主机
- upgrade更新主机 Docker 版本为最新
- url获取主机的 URL
- version输出 docker-machine 版本信息
- help输出帮助信息

每个命令，又带有不同的参数，可以通过

$ docker-machine COMMAND --help

来查看具体的用法。

 

 

 

 

 

 

# 附录A Docker 命令查询

 

### 基本语法

Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。

- 客户端命令：基本命令格式为docker [OPTIONS] COMMAND [arg...]；
- 服务端命令：基本命令格式为dockerd [OPTIONS]。

可以通过 man docker 或 docker help 来查看这些命令。

### 客户端命令选项

- --config=""：指定客户端配置文件，默认为/.docker；
- -D=true|false：是否使用 debug 模式。默认不开启；
- -H, --host=[]：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字（unix:///path/to/socket），文件句柄（fd://socketfd）或 tcp 套接字（tcp://[host[:port]]），默认为 unix:///var/run/docker.sock；
- -l, --log-level="debug|info|warn|error|fatal"：指定日志输出级别；
- --tls=true|false：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；
- --tlscacert= /.docker/ca.pem：TLS CA 签名的可信证书文件路径；
- --tlscert= /.docker/cert.pem：TLS 可信证书文件路径；
- --tlscert= /.docker/key.pem：TLS 密钥文件路径；
- --tlsverify=true|false：启用 TLS 校验，默认为否。

### dockerd 命令选项

- --api-cors-header=""：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 “*”；
- --authorization-plugin=""：载入认证的插件；
- -b=""：将容器挂载到一个已存在的网桥上。指定为 'none' 时则禁用容器的网络，与 --bip 选项互斥；
- --bip=""：让动态创建的 docker0 网桥采用给定的 CIDR 地址; 与 -b 选项互斥；
- --cgroup-parent=""：指定 cgroup 的父组，默认 fs cgroup 驱动为/docker，systemd cgroup 驱动为 slice；
- --cluster-store=""：构成集群（如 Swarm）时，集群键值数据库服务地址；
- --cluster-advertise=""：构成集群时，自身的被访问地址，可以为host:port 或 interface:port；
- --cluster-store-opt=""：构成集群时，键值数据库的配置选项；
- --config-file="/etc/docker/daemon.json"：daemon 配置文件路径；
- --containerd=""：containerd 文件的路径；
- -D, --debug=true|false：是否使用 Debug 模式。缺省为 false；
- --default-gateway=""：容器的 IPv4 网关地址，必须在网桥的子网段内；
- --default-gateway-v6=""：容器的 IPv6 网关地址；
- --default-ulimit=[]：默认的 ulimit 值；
- --disable-legacy-registry=true|false：是否允许访问旧版本的镜像仓库服务器；
- --dns=""：指定容器使用的 DNS 服务器地址；
- --dns-opt=""：DNS 选项；
- --dns-search=[]：DNS 搜索域；
- --exec-opt=[]：运行时的执行选项；
- --exec-root=""：容器执行状态文件的根路径，默认为/var/run/docker；
- --fixed-cidr=""：限定分配 IPv4 地址范围；
- --fixed-cidr-v6=""：限定分配 IPv6 地址范围；
- -G, --group=""：分配给 unix 套接字的组，默认为docker；
- -g, --graph=""：Docker 运行时的根路径，默认为/var/lib/docker；
- -H, --host=[]：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字（unix:///path/to/socket），文件句柄（fd://socketfd）或 tcp 套接字（tcp://[host[:port]]），默认为 unix:///var/run/docker.sock；
- --icc=true|false：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。
- --insecure-registry=[]：允许访问给定的非安全仓库服务；
- --ip=""：绑定容器端口时候的默认 IP 地址。缺省为0.0.0；
- --ip-forward=true|false：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；
- --ip-masq=true|false：是否进行地址伪装，用于容器访问外部网络，默认开启；
- --iptables=true|false：是否允许 Docker 添加 iptables 规则。缺省为 true；
- --ipv6=true|false：是否启用 IPv6 支持，默认关闭；
- -l, --log-level="debug|info|warn|error|fatal"：指定日志输出级别；
- --label="[]"：添加指定的键值对标注；
- --log-driver="json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none"：指定日志后端驱动，默认为 json-file；
- --log-opt=[]：日志后端的选项；
- --mtu=VALUE：指定容器网络的 mtu；
- -p=""：指定 daemon 的 PID 文件路径。缺省为/var/run/docker.pid；
- --raw-logs：输出原始，未加色彩的日志信息；
- --registry-mirror=://：指定docker pull 时使用的注册服务器镜像地址；
- -s, --storage-driver=""：指定使用给定的存储后端；
- --selinux-enabled=true|false：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；
- --storage-opt=[]：驱动后端选项；
- --tls=true|false：是否对 Docker daemon 启用 TLS 安全机制，默认为否；
- --tlscacert= /.docker/ca.pem：TLS CA 签名的可信证书文件路径；
- --tlscert= /.docker/cert.pem：TLS 可信证书文件路径；
- --tlscert= /.docker/key.pem：TLS 密钥文件路径；
- --tlsverify=true|false：启用 TLS 校验，默认为否；
- --userland-proxy=true|false：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；
- --userns-remap=default|uid:gid|user:group|user|uid：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。

### 客户端命令

可以通过 docker COMMAND --help 来查看这些命令的具体用法。

- attach：依附到一个正在运行的容器中；
- build：从一个 Dockerfile 创建一个镜像；
- commit：从一个容器的修改中创建一个新的镜像；
- cp：在容器和本地宿主系统之间复制文件中；
- create：创建一个新容器，但并不运行它；
- diff：检查一个容器内文件系统的修改，包括修改和增加；
- events：从服务端获取实时的事件；
- exec：在运行的容器内执行命令；
- export：导出容器内容为一个 tar 包；
- history：显示一个镜像的历史信息；
- images：列出存在的镜像；
- import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；
- info：显示一些相关的系统信息；
- inspect：显示一个容器的具体配置信息；
- kill：关闭一个运行中的容器 (包括进程和所有相关资源)；
- load：从一个 tar 包中加载一个镜像；
- login：注册或登录到一个 Docker 的仓库服务器；
- logout：从 Docker 的仓库服务器登出；
- logs：获取容器的 log 信息；
- network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；
- node：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；
- pause：暂停一个容器中的所有进程；
- port：查找一个 nat 到一个私有网口的公共口；
- ps：列出主机上的容器；
- pull：从一个Docker的仓库服务器下拉一个镜像或仓库；
- push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；
- rename：重命名一个容器；
- restart：重启一个运行中的容器；
- rm：删除给定的若干个容器；
- rmi：删除给定的若干个镜像；
- run：创建一个新容器，并在其中运行给定命令；
- save：保存一个镜像为 tar 包文件；
- search：在 Docker index 中搜索一个镜像；
- service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；
- start：启动一个容器；
- stats：输出（一个或多个）容器的资源使用统计信息；
- stop：终止一个运行中的容器；
- swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；
- tag：为一个镜像打标签；
- top：查看一个容器中的正在运行的进程信息；
- unpause：将一个容器内所有的进程从暂停状态中恢复；
- update：更新指定的若干容器的配置信息；
- version：输出 Docker 的版本信息；
- volume：管理 Docker volume，包括查看、创建、删除等；
- wait：阻塞直到一个容器终止，然后输出它的退出符。

### 一张图总结 Docker 的命令

 ![](C:\Users\dell\Desktop\docker命令.png)

Docker 命令总结

 

# 附录B Dockerfile 最佳实践

 

### 一般性的指南和建议

#### 容器应该是短暂的

通过 Dockerfile 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。

#### 使用 .dockerignore 文件

使用 Dockerfile 构建镜像时最好是将 Dockerfile 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 .dockerignore 文件来指定要忽略的文件和目录。.dockerignore 文件的排除模式语法和 Git 的 .gitignore 文件相似。

#### 使用多阶段构建

在 Docker 17.05 以上版本中，你可以使用 [多阶段构建](https://docker_practice.gitee.io/image/multistage-builds.html) 来减少所构建镜像的大小。

#### 避免安装不必要的包

为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。

#### 一个容器只运行一个进程

应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。

如果容器互相依赖，你可以使用 [Docker 自定义网络](https://docker_practice.gitee.io/network/linking.html) 来把这些容器连接起来。

#### 镜像层数尽可能少

你需要在 Dockerfile 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。

#### 将多行参数排序

将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 PRs 阅读和审查。建议在反斜杠符号 \ 之前添加一个空格，以增加可读性。

下面是来自 buildpack-deps 镜像的例子：

RUN apt-get update && apt-get install -y \  bzr \  cvs \  git \  mercurial \  subversion

#### 构建缓存

在镜像的构建过程中，Docker 会遍历 Dockerfile 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用 --no-cache=true 选项。

但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：

- 从一个基础镜像开始（FROM指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。
- 在大多数情况下，只需要简单地对比Dockerfile 中的指令和子镜像。然而，有些指令需要更多的检查和解释。
- 对于ADD 和 COPY 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。
- 除了ADD 和 COPY 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 RUN apt-get -y update 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。

一旦缓存失效，所有后续的 Dockerfile 指令都将产生新的镜像，缓存不会被使用。

### Dockerfile 指令

下面针对 Dockerfile 中各种指令的最佳编写方式给出建议。

**FROM**

尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 [Alpine](https://hub.docker.com/_/alpine/) 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。

**LABEL**

你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 LABEL 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。# 开头的行是注释内容。

注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。

\# Set one or more individual labelsLABEL com.example.version="0.0.1-beta" LABEL vendor="ACME Incorporated" LABEL com.example.release-date="2015-02-12" LABEL com.example.version.is-production=""

一个镜像可以包含多个标签，但建议将多个标签放入到一个 LABEL 指令中。

\# Set multiple labels at once, using line-continuation characters to break long linesLABEL vendor=ACME\ Incorporated \      com.example.is-beta= \      com.example.is-production="" \      com.example.version="0.0.1-beta" \      com.example.release-date="2015-02-12"

关于标签可以接受的键值对，参考 [Understanding object labels](https://docs.docker.com/engine/userguide/labels-custom-metadata/)。关于查询标签信息，参考 [Managing labels on objects](https://docs.docker.com/engine/userguide/labels-custom-metadata/#managing-labels-on-objects)。

**RUN**

为了保持 Dockerfile 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 RUN 指令用反斜杠 \ 分割成多行。

**apt-get**

RUN 指令最常见的用法是安装包用的 apt-get。因为 RUN apt-get 指令会安装包，所以有几个问题需要注意。

不要使用 RUN apt-get upgrade 或 dist-upgrade，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 foo，需要升级，使用 apt-get install -y foo 就行，该指令会自动升级 foo 包。

永远将 RUN apt-get update 和 apt-get install 组合成一条 RUN 声明，例如：

RUN apt-get update && apt-get install -y \        package-bar \        package-baz \        package-foo

将 apt-get update 放在一条单独的 RUN 声明中会导致缓存问题以及后续的 apt-get install 失败。比如，假设你有一个 Dockerfile 文件：

FROM ubuntu:14.04 RUN apt-get update RUN apt-get install -y curl

构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 apt-get install 添加了一个包：

FROM ubuntu:14.04 RUN apt-get update RUN apt-get install -y curl nginx

Docker 发现修改后的 RUN apt-get update 指令和之前的完全一样。所以，apt-get update 不会执行，而是使用之前的缓存镜像。因为 apt-get update 没有运行，后面的 apt-get install 可能安装的是过时的 curl 和 nginx 版本。

使用 RUN apt-get update && apt-get install -y 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 cache busting。你也可以显示指定一个包的版本号来达到 cache-busting，这就是所谓的固定版本，例如：

RUN apt-get update && apt-get install -y \    package-bar \    package-baz \    package-foo=1.3.*

固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。

下面是一个 RUN 指令的示例模板，展示了所有关于 apt-get 的建议。

RUN apt-get update && apt-get install -y \    aufs-tools \    automake \    build-essential \    curl \    dpkg-sig \    libcap-dev \    libsqlite3-dev \    mercurial \    reprepro \    ruby1.9.1 \    ruby1.9.1-dev \    s3cmd=1.1.* \ && rm -rf /var/lib/apt/lists/*

其中 s3cmd 指令指定了一个版本号 1.1.*。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 apt-get udpate 缓存失效并确保安装的是新版本。

另外，清理掉 apt 缓存 var/lib/apt/lists 可以减小镜像大小。因为 RUN 指令的开头为 apt-get udpate，包缓存总是会在 apt-get install 之前刷新。

注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。

**CMD**

CMD 指令用于执行目标镜像中包含的软件，可以包含参数。CMD 大多数情况下都应该以 CMD ["executable", "param1", "param2"...] 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 Apache)，你可能会执行类似于 CMD ["apache2", "-DFOREGROUND"] 形式的命令。我们建议任何服务镜像都使用这种形式的命令。

多数情况下，CMD 都需要一个交互式的 shell (bash, Python, perl 等)，例如 CMD ["perl", "-de0"]，或者 CMD ["PHP", "-a"]。使用这种形式意味着，当你执行类似 docker run -it python 时，你会进入一个准备好的 shell 中。CMD 应该在极少的情况下才能以 CMD ["param", "param"] 的形式与 ENTRYPOINT协同使用，除非你和你的镜像使用者都对 ENTRYPOINT 的工作方式十分熟悉。

**EXPOSE**

EXPOSE 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 Apache web 服务的镜像应该使用 EXPOSE 80，而提供 MongoDB 服务的镜像使用 EXPOSE 27017。

对于外部访问，用户可以在执行 docker run 时使用一个标志来指示如何将指定的端口映射到所选择的端口。

**ENV**

为了方便新程序运行，你可以使用 ENV 来为容器中安装的程序更新 PATH 环境变量。例如使用 ENV PATH /usr/local/nginx/bin:$PATH 来确保 CMD ["nginx"] 能正确运行。

ENV 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 PGDATA。

最后，ENV 也能用于设置常见的版本号，比如下面的示例：

ENV PG_MAJOR 9.3 ENV PG_VERSION 9.3.4 RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && … ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH

类似于程序中的常量，这种方法可以让你只需改变 ENV 指令来自动的改变容器中的软件版本。

**ADD 和 COPY**

虽然 ADD 和 COPY 功能类似，但一般优先使用 COPY。因为它比 ADD 更透明。COPY 只支持简单将本地文件拷贝到容器中，而 ADD 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，ADD的最佳用例是将本地 tar 文件自动提取到镜像中，例如 ADD rootfs.tar.xz。

如果你的 Dockerfile 有多个步骤需要使用上下文中不同的文件。单独 COPY 每个文件，而不是一次性的 COPY 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：

COPY requirements.txt /tmp/ RUN pip install --requirement /tmp/requirements.txt COPY . /tmp/

如果将 COPY . /tmp/ 放置在 RUN 指令之前，只要 . 目录中任何一个文件变化，都会导致后续指令的缓存失效。

为了让镜像尽量小，最好不要使用 ADD 指令从远程 URL 获取包，而是使用 curl 和 wget。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：

ADD http://example.com/big.tar.xz /usr/src/things/ RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things RUN make -C /usr/src/things all

而是应该使用下面这种方法：

RUN mkdir -p /usr/src/things \    && curl -SL http://example.com/big.tar.xz \    | tar -xJC /usr/src/things \    && make -C /usr/src/things all

上面使用的管道操作，所以没有中间文件需要删除。

对于其他不需要 ADD 的自动提取功能的文件或目录，你应该使用 COPY。

ENTRYPOINT

ENTRYPOINT 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 CMD 提供默认选项）。

例如，下面的示例镜像提供了命令行工具 s3cmd:

ENTRYPOINT ["s3cmd"] CMD ["--help"]

现在直接运行该镜像创建的容器会显示命令帮助：

$ docker run s3cmd

或者提供正确的参数来执行某个命令：

$ docker run s3cmd ls s3://mybucket

这样镜像名可以当成命令行的参考。

ENTRYPOINT 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。

例如，Postgres 官方镜像使用下面的脚本作为 ENTRYPOINT：

\#!/bin/bashset -e if [ "$1" = 'postgres' ]; then    chown -R postgres "$PGDATA"     if [ -z "$(ls -A "$PGDATA")" ]; then        gosu postgres initdb    fi     exec gosu postgres "$@"fi exec "$@"

注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。

该辅助脚本被拷贝到容器，并在容器启动时通过 ENTRYPOINT 执行：

COPY ./docker-entrypoint.sh / ENTRYPOINT ["/docker-entrypoint.sh"]

该脚本可以让用户用几种不同的方式和 Postgres 交互。

你可以很简单地启动 Postgres：

$ docker run postgres

也可以执行 Postgres 并传递参数：

$ docker run postgres postgres --help

最后，你还可以启动另外一个完全不同的工具，比如 Bash：

$ docker run --rm -it postgres bash

**VOLUME**

VOLUME 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 VOLUME来管理镜像中的可变部分和用户可以改变的部分。

**USER**

如果某个服务不需要特权执行，建议使用 USER 指令切换到非 root 用户。先在 Dockerfile 中使用类似 RUN groupadd -r postgres && useradd -r -g postgres postgres 的指令创建用户和用户组。

注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID。

你应该避免使用 sudo，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 sudo 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 [gosu](https://github.com/tianon/gosu)。

最后，为了减少层数和复杂度，避免频繁地使用 USER 来回切换用户。

**WORKDIR**

为了清晰性和可靠性，你应该总是在 WORKDIR 中使用绝对路径。另外，你应该使用 WORKDIR 来替代类似于 RUN cd ... && do-something 的指令，后者难以阅读、排错和维护。

### 官方仓库示例

这些官方仓库的 Dockerfile 都是参考典范：<https://github.com/docker-library/docs>

 

 

# 附录 C 常见问题总结

 

 

#### **Using systemd to control the Docker daemon**

**Article ID: KB000465**

https://success.docker.com/article/using-systemd-to-control-the-docker-daemon

Systemd provides a standard process for controlling programs / processes on Linux hosts. In effect it has replaced initd. If you're using a somewhat modern Linux system (RHEL 7.x, SuSE 12, Ubuntu 15, etc), then you will encounter systemd. One of the nice things about systemd is that it is a single command that can be used to manage almost all aspects of a process. Also, systemd is easily configurable through what are known as systemd unit files.

The following explains how systemd can be used with the Docker daemon. For the most part this should not be any different from how systemd would interact with any service.

**Prerequisites**

- A system that uses systemd
- Docker installed, preferably the latest

**Verifying the Status and Health of the Docker Daemon**

The systemctl status command provides not only information about whether the service / process is running (active), but also whether it is enabled to start at boot of the machine. This in itself would have required multiple programs (chkconfig etc) to query. Additionally, it shows the default unit file loaded in the following line:

​    Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)

Among other information, useful messages about the PID, memory consumed, arguments (DOCKER_OPTS) and the last 10 lines (aka tail) are also shown:

​    [ec2-user@ip-10-0-46-113 ~]$ sudo systemctl status docker    docker.service - Docker Application Container Engine       Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)       Active: active (running) since Tue 2016-02-02 18:13:42 EST; 2 days ago         Docs: https://docs.docker.com     Main PID: 16915 (docker)       Memory: 14.7M       CGroup: /system.slice/docker.service               ├─16915 /usr/bin/docker daemon -H fd://               └─20162 docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 3375 -container-ip 172.17.0.2 -container-port 2375     Feb 03 19:51:35 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T19:51:35.411425044-05:00" level=info msg="GET /v1.21/conta.../json"    Feb 03 19:51:46 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T19:51:46.575906700-05:00" level=info msg="GET /v1.21/version"    Feb 03 19:57:51 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T19:57:51.748731356-05:00" level=info msg="GET /v1.21/conta.../json"    Feb 03 19:57:59 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T19:57:59.959082130-05:00" level=info msg="POST /v1.21/cont...?t=10"    Feb 03 19:58:03 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T19:58:03.958291300-05:00" level=info msg="GET /v1.21/conta...mit=1"    Feb 03 19:58:04 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T19:58:04.000435804-05:00" level=info msg="GET /v1.21/conta.../json"    Feb 03 19:58:04 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T19:58:04.001717319-05:00" level=info msg="GET /v1.21/conta...l=all"    Feb 03 20:08:52 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T20:08:52.811916273-05:00" level=info msg="GET /v1.21/conta...mit=1"    Feb 03 20:08:52 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T20:08:52.855966139-05:00" level=info msg="GET /v1.21/conta.../json"    Feb 03 20:08:52 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T20:08:52.857644962-05:00" level=info msg="GET /v1.21/conta...l=all"    Hint: Some lines were ellipsized, use -l to show in full.

To enable the daemon to start at boot time or not use sudo systemctl enable docker and sudo systemctl disable docker respectively.

**Overriding Defaults for the Docker Daemon**

By default the systemd configuration files controlling the service are under the folder/usr/lib/systemd/system. This is also evident in the Loaded: line in the output of the systemctl status command.

​    [ec2-user@ip-10-0-46-113 ~]$ sudo systemctl status docker.service | grep Loaded       Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)

The docker.service file contains all the configuration options for the docker process. The options are organized under sections [Unit], [Service] and [Install]. The format of the file is very similar to an init file, with name=value pairs in each section.

To override the daemon options, it is recommended not to edit this file. Instead, an override file should be used. The override file would contain just the options that need to be changed along with the section heading it is under.

Now many instructions about systemd describe the need to create a separate directory tree and host the override file in that path. While this will work, it is not necessary to create it by hand, nor is it necessary to remember where exactly the override file(s) need to go. Instead it is easier to just run systemctl edit docker. So, say we want to modify the daemon options so that the service is accessible over the network and also have it bind to the unix socker at/var/run/docker.sock. We would first want to see what the option is set to currently. This can be done using the systemctl cat like below:

​    [ec2-user@ip-10-0-46-113 ~]$ sudo systemctl cat docker | grep ExecStart    ExecStart=/usr/bin/docker daemon -H fd://    [ec2-user@ip-10-0-46-113 ~]$

The nice thing about the command above is that it shows a unified view of all options and takes into consideration any overrides that may have been applied.

To change the value of an option, ExecStart in this case, do the following:

​    [ec2-user@ip-10-0-46-113 ~]$ sudo systemctl edit docker

This will create the necessary directory structure under /etc/systemd/system/docker.service.dand open an editor (using the default editor configured for the user) to the override file. Add the section below into the editor:

​    [Service]    ExecStart=    ExecStart=/usr/bin/docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock

It was necessary to clear out ExecStart using ExecStart= before setting it to the override value. This is only required for some options and most options in the configuration file would not need to be cleared like this

Using systemctl edit also ensures that the override settings are loaded. Had you edited the file manually using vi etc, you would have to run sudo systemctl daemon-reloadin order for the new settings to be loaded.

The only reason you may want to run the systemctl daemon-reload command is if you made a typo or error in the override file when you did systemctl edit. For this you would need to be aware of the path of the override file, which is/etc/systemd/system/docker.service.d/override.conf.

Finally, in order for the override settings to take effect, restart the daemon using systemctl restart docker. Again, the status of the new settings and the process health can be verified by running systemctl status docker.

​    [ec2-user@ip-10-0-46-113 ~]$ sudo systemctl edit docker    [ec2-user@ip-10-0-46-113 ~]$ sudo systemctl status docker    docker.service - Docker Application Container Engine       Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)      Drop-In: /etc/systemd/system/docker.service.d               └─override.conf       Active: active (running) since Fri 2016-02-05 18:49:14 EST; 1min 28s ago         Docs: https://docs.docker.com     Main PID: 24850 (docker)       CGroup: /system.slice/docker.service               └─24850 /usr/bin/docker daemon -H tcp://0.0.0.0:9999     Feb 05 18:49:14 ip-10-0-46-113.ec2.internal docker[24850]: time="2016-02-05T18:49:14.335228582-0...."    Feb 05 18:49:14 ip-10-0-46-113.ec2.internal docker[24850]: time="2016-02-05T18:49:14.378558031-0...""    Feb 05 18:49:14 ip-10-0-46-113.ec2.internal docker[24850]: time="2016-02-05T18:49:14.386429304-0...e"    Feb 05 18:49:14 ip-10-0-46-113.ec2.internal docker[24850]: time="2016-02-05T18:49:14.419513857-0...s"    Feb 05 18:49:14 ip-10-0-46-113.ec2.internal docker[24850]: time="2016-02-05T18:49:14.466389616-0...."    Feb 05 18:49:14 ip-10-0-46-113.ec2.internal docker[24850]: ....    Feb 05 18:49:14 ip-10-0-46-113.ec2.internal docker[24850]: time="2016-02-05T18:49:14.469497693-0...."    Feb 05 18:49:14 ip-10-0-46-113.ec2.internal docker[24850]: time="2016-02-05T18:49:14.469518888-0...n"    Feb 05 18:49:14 ip-10-0-46-113.ec2.internal docker[24850]: time="2016-02-05T18:49:14.469537359-0...s3    Feb 05 18:49:14 ip-10-0-46-113.ec2.internal systemd[1]: Started Docker Application Container Engine.    Hint: Some lines were ellipsized, use -l to show in full.    [ec2-user@ip-10-0-46-113 ~]$

**Viewing Logs Related to the Docker Service**

To view logs related to the Docker service, run the following command:

journalctl -u docker

The output will be similar to the following:

ec2-user@ip-10-0-46-113 ~]$ journalctl -u docker-- Logs begin at Tue 2016-02-02 11:20:18 EST, end at Fri 2016-02-05 19:18:49 EST. --Feb 02 18:13:40 ip-10-0-46-113.ec2.internal systemd[1]: Starting Docker Application Container Engine.Feb 02 18:13:40 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-02T18:13:40.394723367-05:00"Feb 02 18:13:40 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-02T18:13:40.464672420-05:00"Feb 02 18:13:42 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-02T18:13:42.225872353-05:00"Feb 02 18:13:42 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-02T18:13:42.245163371-05:00"Feb 02 18:13:42 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-02T18:13:42.283163052-05:00"Feb 02 18:13:42 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-02T18:13:42.373603957-05:00"Feb 03 10:33:06 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T10:33:06.826177379-05:00"Feb 03 10:33:07 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T10:33:07.104231280-05:00"Feb 03 10:33:10 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T10:33:10.474069661-05:00"Feb 03 10:33:27 ip-10-0-46-113.ec2.internal docker[16915]: time="2016-02-03T10:33:27.031864375-05:00"lines 1-12...skipping...

 

 

#### [CentOS7安装docker 启动不了解决篇](http://www.cnblogs.com/amoyzhu/p/5261393.html)

http://www.cnblogs.com/amoyzhu/p/5261393.html

[root@test ~]# yum update

[root@test ~]# yum install docker

 

[root@test ~]# service docker start

Redirecting to /bin/systemctl start  docker.service

Job for docker.service failed because the control process exited with error code. See "systemctl status docker.service" and "journalctl -xe" for details.

[root@test ~]# systemctl status docker.service

- docker.service - Docker Application Container Engine

   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)

   Active: inactive (dead) (Result: exit-code) since 四 2016-03-10 13:01:21 CST; 7s ago

​     Docs: http://docs.docker.com

  Process: 29939 ExecStart=/usr/bin/docker daemon $OPTIONS $DOCKER_STORAGE_OPTIONS $DOCKER_NETWORK_OPTIONS $ADD_REGISTRY $BLOCK_REGISTRY $INSECURE_REGISTRY (code=exited, status=2)

 Main PID: 29939 (code=exited, status=2)

   CGroup: /system.slice/docker.service

​           └─29970 mkfs.ext4 -E nodiscard,lazy_itable_init=0,lazy_journal_ini...

 

3月 10 13:01:20 test.mayocase.com systemd[1]: Failed to start Docker Applic....

3月 10 13:01:20 test.mayocase.com systemd[1]: Unit docker.service entered f....

3月 10 13:01:20 test.mayocase.com systemd[1]: docker.service failed.

3月 10 13:01:21 test.mayocase.com systemd[1]: docker.service holdoff time o....

Hint: Some lines were ellipsized, use -l to show in full.

[root@test ~]# 

 

使用yum install docker安装完后启动不了

[root@apptest ~]# service docker start

Redirecting to /bin/systemctl start  docker.service

一直停留在以上步骤

可以使用以下命令来安装，即可成功。

一个问题让我折腾了两天，试过关闭防火墙，关闭selinux，重装系统，等等网上能查到的方法都解决不了。

如果大家解决了，回复感谢下我吧。

 

[root@apptest ~]# yum remove docker

[root@apptest ~]# yum remove docker-selinux

 

[root@test yum.repos.d]# vi  /etc/yum.repos.d/docker.repo

 

[dockerrepo]

name=Docker Repository

baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/

enabled=1

gpgcheck=1

gpgkey=<https://yum.dockerproject.org/gpg>

 

[root@test yum.repos.d]# yum install docker-engine

 

已安装:

  docker-engine.x86_64 0:1.10.2-1.el7.centos                                    

 

作为依赖被安装:

  docker-engine-selinux.noarch 0:1.10.2-1.el7.centos   

 

[root@apptest ~]# service docker start

Redirecting to /bin/systemctl start  docker.service

[root@apptest ~]# docker images

REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE

 

[root@test yum.repos.d]# docker version

Client:

 Version:      1.10.2

 API version:  1.22

 Go version:   go1.5.3

 Git commit:   c3959b1

 Built:        Mon Feb 22 16:16:33 2016

 OS/Arch:      linux/amd64

 

Server:

 Version:      1.10.2

 API version:  1.22

 Go version:   go1.5.3

 Git commit:   c3959b1

 Built:        Mon Feb 22 16:16:33 2016

 OS/Arch:      linux/amd64

[root@test yum.repos.d]# 

 

或者使用以下方法

 

[root@apptest ~]# curl -fsSL https://get.docker.com/ | sh

\+ sh -c 'sleep 3; yum -y -q install docker-engine'

警告：/var/cache/yum/x86_64/7/docker-main-repo/packages/docker-engine-selinux-1.10.2-1.el7.centos.noarch.rpm: 头V4 RSA/SHA512 Signature, 密钥 ID 2c52609d: NOKEY

docker-engine-selinux-1.10.2-1.el7.centos.noarch.rpm 的公钥尚未安装

导入 GPG key 0x2C52609D:

 用户ID     : "Docker Release Tool (releasedocker) <docker@docker.com>"

 指纹       : 5811 8e89 f3a9 1289 7c07 0adb f762 2157 2c52 609d

 来自       : https://yum.dockerproject.org/gpg

setsebool:  SELinux is disabled.

\+ sh -c 'docker version'

Client:

 Version:      1.10.2

 API version:  1.22

 Go version:   go1.5.3

 Git commit:   c3959b1

 Built:        Mon Feb 22 16:16:33 2016

 OS/Arch:      linux/amd64

Cannot connect to the Docker daemon. Is the docker daemon running on this host?

 

If you would like to use Docker as a non-root user, you should now consider

adding your user to the "docker" group with something like:

 

  sudo usermod -aG docker your-user

 

Remember that you will have to log out and back in for this to take effect!

 

[root@apptest ~]# 

 

[root@apptest ~]# service docker start

Redirecting to /bin/systemctl start  docker.service

[root@apptest ~]# docker images

REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE

[root@apptest ~]# 

 

 

官方网址可查

https://docs.docker.com/engine/installation/linux/centos/

 

 

 

#### [CentOS7 启动docker.service失败(code=exited, status=1/FAILURE)](http://www.cnblogs.com/rysinal/p/6364182.html)

http://www.cnblogs.com/rysinal/p/6364182.html

启动报错

Job for docker.service failed because the control process exited with error code. See "systemctl status docker.service" and "journalctl -xe" for details.

查看状态

[[root@docker-master](mailto:root@docker-master) ~]# systemctl status docker.service

- docker.service - Docker Application Container Engine
  Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)
  Active: failed (Result: exit-code) since Sat 2017-02-04 10:22:05 CST; 9s ago
  Docs: [https://docs.docker.com](https://docs.docker.com/)
  Process: 1303 ExecStart=/usr/bin/dockerd --storage-driver=devicemapper --storage-opt=dm.thinpooldev=/dev/mapper/docker-thinpool --storage-opt=dm.use_deferred_removal=true --storage-opt=dm.use_deferred_deletion=true --bridge=bridge0 (code=exited, status=1/FAILURE)
  Main PID: 1303 (code=exited, status=1/FAILURE)

Feb 04 10:22:05 docker-master dockerd[1303]: time="2017-02-04T10:22:05.557580671+08:00" level=warning msg="devmapper: Base device already exists and has filesystem xfs on it. User speci... be ignored."
Feb 04 10:22:05 docker-master dockerd[1303]: time="2017-02-04T10:22:05.588961854+08:00" level=info msg="Graph migration to content-addressability took 0.00 seconds"
Feb 04 10:22:05 docker-master dockerd[1303]: time="2017-02-04T10:22:05.589783659+08:00" level=info msg="Loading containers: start."
Feb 04 10:22:05 docker-master dockerd[1303]: ..time="2017-02-04T10:22:05.600874044+08:00" level=info msg="Firewalld running: true"
Feb 04 10:22:05 docker-master dockerd[1303]: time="2017-02-04T10:22:05.712604289+08:00" level=warning msg="could not create bridge network for id 845cd78db010b38a37d75189ca02ea1ea86615e...ted manually"
Feb 04 10:22:05 docker-master dockerd[1303]: time="2017-02-04T10:22:05.744068183+08:00" level=fatal msg="Error starting daemon: Error initializing network controller: Error creating def...ted manually"
Feb 04 10:22:05 docker-master systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE
Feb 04 10:22:05 docker-master systemd[1]: Failed to start Docker Application Container Engine.
Feb 04 10:22:05 docker-master systemd[1]: Unit docker.service entered failed state.
Feb 04 10:22:05 docker-master systemd[1]: docker.service failed.
Hint: Some lines were ellipsized, use -l to show in full.

原因

启动文件报错

之前做实验在启动文件/usr/lib/systemd/system/docker.service里加了一个参数--bridge=bridge0

而通过查看网卡信息 发现之前创建的虚拟网卡不在了

[[root@docker-master](mailto:root@docker-master) ~]# ip addr

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: eno16777736: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:0c:29:0f:b0:24 brd ff:ff:ff:ff:ff:ff    inet 192.168.178.137/24 brd 192.168.178.255 scope global dynamic eno16777736       valid_lft 1514sec preferred_lft 1514sec    inet6 fe80::20c:29ff:fe0f:b024/64 scope link        valid_lft forever preferred_lft forever

解决

1.修改删除启动文件/usr/lib/systemd/system/docker.service里的参数--bridge=bridge0

或者

2.新建网卡bridge0

 

 

# 附录D Docker安装配置使用

 

 

## Get Docker CE for Ubuntu

https://docs.docker.com/install/linux/docker-ce/ubuntu/

To get started with Docker CE on Ubuntu, make sure you [meet the prerequisites](https://docs.docker.com/install/linux/docker-ce/ubuntu/#prerequisites), then[install Docker](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce).

### Prerequisites

#### Docker EE customers

To install Docker Enterprise Edition (Docker EE), go to [Get Docker EE for Ubuntu](https://docs.docker.com/install/linux/docker-ee/ubuntu/) **instead of this topic**.

To learn more about Docker EE, see [Docker Enterprise Edition](https://www.docker.com/enterprise-edition/).

#### OS requirements

To install Docker CE, you need the 64-bit version of one of these Ubuntu versions:

- Artful 17.10 (Docker CE 17.11 Edge and higher only)
- Xenial 16.04 (LTS)
- Trusty 14.04 (LTS)

Docker CE is supported on Ubuntu on x86_64, armhf, s390x (IBM Z), and ppc64le(IBM Power) architectures.

**ppc64le** **and** **s390x** **limitations**: Packages for IBM Z and Power architectures are only available on Ubuntu Xenial and above.

#### Uninstall old versions

Older versions of Docker were called docker or docker-engine. If these are installed, uninstall them:

$ sudo apt-get remove docker docker-engine docker.io

It’s OK if apt-get reports that none of these packages are installed.

The contents of /var/lib/docker/, including images, containers, volumes, and networks, are preserved. The Docker CE package is now called docker-ce.

#### Supported storage drivers

Docker CE on Ubuntu supports overlay2 and aufs storage drivers.

- For new installations on version 4 and higher of the Linux kernel, overlay2 is supported and preferred over aufs.
- For version 3 of the Linux kernel, aufs is supported because overlay oroverlay2 drivers are not supported by that kernel version.

If you need to use aufs, you need to do additional preparation as outlined below.

**EXTRA STEPS FOR AUFS**

- Xenial 16.04 and newer
- Trusty 14.04

For Ubuntu 16.04 and higher, the Linux kernel includes support for OverlayFS, and Docker CE uses the overlay2 storage driver by default. If you need to use aufs instead, you need to configure it manually. See [aufs](https://docs.docker.com/engine/userguide/storagedriver/aufs-driver/)

### Install Docker CE

You can install Docker CE in different ways, depending on your needs:

- Most users [set up Docker’s repositories](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-repository)and install from them, for ease of installation and upgrade tasks. This is the recommended approach.
- Some users download the DEB package and [install it manually](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-from-a-package)and manage upgrades completely manually. This is useful in situations such as installing Docker on air-gapped systems with no access to the internet.
- In testing and development environments, some users choose to use automated[convenience scripts](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-convenience-script)to install Docker.

#### Install using the repository

Before you install Docker CE for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository.

##### SET UP THE REPOSITORY

1. Update the aptpackage index:
2. $ sudo apt-get update
3. Install packages to allow aptto use a repository over HTTPS:
4. $ sudo apt-get install \     apt-transport-https \6.         ca-certificates \7.         curl \8.         software-properties-common
5. Add Docker’s official GPG key:
6. $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

Verify that you now have the key with the fingerprint9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88, by searching for the last 8 characters of the fingerprint.

$ sudo apt-key fingerprint 0EBFCD88 pub   4096R/0EBFCD88 2017-02-22      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88uid                  Docker Release (CE deb) <docker@docker.com>sub   4096R/F273FCD8 2017-02-22

1. Use the following command to set up the **stable** You always need the **stable**repository, even if you want to install builds from the **edge** or **test** repositories as well. To add the **edge** or **test** repository, add the word edge or test (or both) after the word stable in the commands below.

**Note**: The lsb_release -cs sub-command below returns the name of your Ubuntu distribution, such as xenial. Sometimes, in a distribution like Linux Mint, you might need to change $(lsb_release -cs) to your parent Ubuntu distribution. For example, if you are using Linux Mint Rafaela, you could use trusty.

1. - x86_64 / amd64
   - armhf
   - IBM Power (ppc64le)
   - IBM Z (s390x)

$ sudo add-apt-repository \   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \   $(lsb_release -cs) \   stable"

**Note**: Starting with Docker 17.06, stable releases are also pushed to the **edge**and **test** repositories.

[Learn about **stable** and **edge** channels](https://docs.docker.com/install/).

##### INSTALL DOCKER CE

1. Update the aptpackage index.
2. $ sudo apt-get update
3. Install the *latest version*of Docker CE, or go to the next step to install a specific version:
4. $ sudo apt-get install docker-ce

**Got multiple Docker repositories?**

If you have multiple Docker repositories enabled, installing or updating without specifying a version in the apt-get install or apt-get updatecommand always installs the highest possible version, which may not be appropriate for your stability needs.

1. To install a *specific version*of Docker CE, list the available versions in the repo, then select and install:
2. List the versions available in your repo:

$ apt-cache madison docker-ce docker-ce | 18.03.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages

1. Install a specific version by its fully qualified package name, which is the package name (docker-ce) plus the version string (2nd column) up to the first hyphen, separated by a an equals sign (=), for example, docker-ce=18.03.0.ce.

$ sudo apt-get install docker-ce=<VERSION>

The Docker daemon starts automatically.

1. Verify that Docker CE is installed correctly by running the hello-world
2. $ sudo docker run hello-world

This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.

Docker CE is installed and running. The docker group is created but no users are added to it. You need to use sudo to run Docker commands. Continue to [Linux postinstall](https://docs.docker.com/install/linux/linux-postinstall/) to allow non-privileged users to run Docker commands and for other optional configuration steps.

##### UPGRADE DOCKER CE

To upgrade Docker CE, first run sudo apt-get update, then follow the [installation instructions](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker), choosing the new version you want to install.

#### Install from a package

If you cannot use Docker’s repository to install Docker CE, you can download the .deb file for your release and install it manually. You need to download a new file each time you want to upgrade Docker CE.

1. Go to <https://download.docker.com/linux/ubuntu/dists/>, choose your Ubuntu version, browse to pool/stable/and choose amd64, armhf, ppc64el, or s390x. Download the .deb file for the Docker version you want to install.

**Note**: To install an **edge** package, change the word stable in the URL to edge. [Learn about **stable** and **edge** channels](https://docs.docker.com/install/).

1. Install Docker CE, changing the path below to the path where you downloaded the Docker package.
2. $ sudo dpkg -i /path/to/package.deb

The Docker daemon starts automatically.

1. Verify that Docker CE is installed correctly by running the hello-world
2. $ sudo docker run hello-world

This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.

Docker CE is installed and running. The docker group is created but no users are added to it. You need to use sudo to run Docker commands. Continue to [Post-installation steps for Linux](https://docs.docker.com/install/linux/linux-postinstall/) to allow non-privileged users to run Docker commands and for other optional configuration steps.

##### UPGRADE DOCKER CE

To upgrade Docker CE, download the newer package file and repeat the [installation procedure](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-from-a-package), pointing to the new file.

#### Install using the convenience script

Docker provides convenience scripts at [get.docker.com](https://get.docker.com/) and [test.docker.com](https://test.docker.com/) for installing edge and testing versions of Docker CE into development environments quickly and non-interactively. The source code for the scripts is in the [docker-install repository](https://github.com/docker/docker-install). **Using these scripts is not recommended for production environments**, and you should understand the potential risks before you use them:

- The scripts require root or sudo privileges to run. Therefore, you should carefully examine and audit the scripts before running them.
- The scripts attempt to detect your Linux distribution and version and configure your package management system for you. In addition, the scripts do not allow you to customize any installation parameters. This may lead to an unsupported configuration, either from Docker’s point of view or from your own organization’s guidelines and standards.
- The scripts install all dependencies and recommendations of the package manager without asking for confirmation. This may install a large number of packages, depending on the current configuration of your host machine.
- The script does not provide options to specify which version of Docker to install, and installs the latest version that is released in the “edge” channel.
- Do not use the convenience script if Docker has already been installed on the host machine using another mechanism.

This example uses the script at [get.docker.com](https://get.docker.com/) to install the latest release of Docker CE on Linux. To install the latest testing version, use [test.docker.com](https://test.docker.com/) instead. In each of the commands below, replace each occurrence of get with test.

**Warning****:**

Always examine scripts downloaded from the internet before running them locally.

$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh <output truncated> If you would like to use Docker as a non-root user, you should now consideradding your user to the "docker" group with something like:   sudo usermod -aG docker your-user Remember to log out and back in for this to take effect! WARNING: Adding a user to the "docker" group grants the ability to run         containers which can be used to obtain root privileges on the         docker host.         Refer to https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface         for more information.

Docker CE is installed. It starts automatically on DEB-based distributions. On RPM-based distributions, you need to start it manually using the appropriate systemctl or servicecommand. As the message indicates, non-root users can’t run Docker commands by default.

##### UPGRADE DOCKER AFTER USING THE CONVENIENCE SCRIPT

If you installed Docker using the convenience script, you should upgrade Docker using your package manager directly. There is no advantage to re-running the convenience script, and it can cause issues if it attempts to re-add repositories which have already been added to the host machine.

### Uninstall Docker CE

1. Uninstall the Docker CE package:
2. $ sudo apt-get purge docker-ce
3. Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:
4. $ sudo rm -rf /var/lib/docker

You must delete any edited configuration files manually.

### Next steps

- Continue to [Post-installation steps for Linux](https://docs.docker.com/install/linux/linux-postinstall/)
- Continue with the [User Guide](https://docs.docker.com/engine/userguide/).

 

 

 

## Get Docker CE for CentOS

https://docs.docker.com/install/linux/docker-ce/centos/

To get started with Docker CE on CentOS, make sure you [meet the prerequisites](https://docs.docker.com/install/linux/docker-ce/centos/#prerequisites), then[install Docker](https://docs.docker.com/install/linux/docker-ce/centos/#install-docker-ce).

### Prerequisites

#### Docker EE customers

To install Docker Enterprise Edition (Docker EE), go to [Get Docker EE for CentOS](https://docs.docker.com/install/linux/docker-ee/centos/) **instead of this topic**.

To learn more about Docker EE, see [Docker Enterprise Edition](https://www.docker.com/enterprise-edition/).

#### OS requirements

To install Docker CE, you need a maintained version of CentOS 7. Archived versions aren’t supported or tested.

The centos-extras repository must be enabled. This repository is enabled by default, but if you have disabled it, you need to [re-enable it](https://wiki.centos.org/AdditionalResources/Repositories).

The overlay2 storage driver is recommended.

#### Uninstall old versions

Older versions of Docker were called docker or docker-engine. If these are installed, uninstall them, along with associated dependencies.

$ sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine

It’s OK if yum reports that none of these packages are installed.

The contents of /var/lib/docker/, including images, containers, volumes, and networks, are preserved. The Docker CE package is now called docker-ce.

### Install Docker CE

You can install Docker CE in different ways, depending on your needs:

- Most users [set up Docker’s repositories](https://docs.docker.com/install/linux/docker-ce/centos/#install-using-the-repository)and install from them, for ease of installation and upgrade tasks. This is the recommended approach.
- Some users download the RPM package and [install it manually](https://docs.docker.com/install/linux/docker-ce/centos/#install-from-a-package)and manage upgrades completely manually. This is useful in situations such as installing Docker on air-gapped systems with no access to the internet.
- In testing and development environments, some users choose to use automated[convenience scripts](https://docs.docker.com/install/linux/docker-ce/centos/#install-using-the-convenience-script)to install Docker.

#### Install using the repository

Before you install Docker CE for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository.

##### SET UP THE REPOSITORY

1. Install required packages. yum-utilsprovides the yum-config-manager utility, and device-mapper-persistent-data and lvm2 are required by the devicemapperstorage driver.
2. $ sudo yum install -y yum-utils \   device-mapper-persistent-data \4.       lvm2
3. Use the following command to set up the **stable** You always need the **stable**repository, even if you want to install builds from the **edge** or **test** repositories as well.
4. $ sudo yum-config-manager \     --add-repo\8.         https://download.docker.com/linux/centos/docker-ce.repo
5. **Optional**: Enable the **edge**and **test** These repositories are included in the docker.repo file above but are disabled by default. You can enable them alongside the stable repository.
6. $ sudo yum-config-manager --enable docker-ce-edge $ sudo yum-config-manager --enable docker-ce-test

You can disable the **edge** or **test** repository by running the yum-config-managercommand with the --disable flag. To re-enable it, use the --enable flag. The following command disables the **edge** repository.

$ sudo yum-config-manager --disable docker-ce-edge

**Note**: Starting with Docker 17.06, stable releases are also pushed to the **edge**and **test** repositories.

[Learn about **stable** and **edge** builds](https://docs.docker.com/install/).

##### INSTALL DOCKER CE

1. Install the *latest version*of Docker CE, or go to the next step to install a specific version:
2. $ sudo yum install docker-ce

If prompted to accept the GPG key, verify that the fingerprint matches060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35, and if so, accept it.

**Got multiple Docker repositories?**

If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command always installs the highest possible version, which may not be appropriate for your stability needs.

Docker is installed but not started. The docker group is created, but no users are added to the group.

1. To install a *specific version*of Docker CE, list the available versions in the repo, then select and install:
2. List and sort the versions available in your repo. This example sorts results by version number, highest to lowest, and is truncated:

$ yum list docker-ce --showduplicates | sort -r docker-ce.x86_64            18.03.0.ce-1.el7.centos             docker-ce-stable

The list returned depends on which repositories are enabled, and is specific to your version of CentOS (indicated by the .el7 suffix in this example).

1. Install a specific version by its fully qualified package name, which is the package name (docker-ce) plus the version string (2nd column) up to the first hyphen, separated by a hyphen (-), for example, docker-ce-18.03.0.ce.

$ sudo yum install docker-ce-<VERSION STRING>

Docker is installed but not started. The docker group is created, but no users are added to the group.

1. Start Docker.
2. $ sudo systemctl start docker
3. Verify that dockeris installed correctly by running the hello-world
4. $ sudo docker run hello-world

This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.

Docker CE is installed and running. You need to use sudo to run Docker commands. Continue to [Linux postinstall](https://docs.docker.com/install/linux/linux-postinstall/) to allow non-privileged users to run Docker commands and for other optional configuration steps.

##### UPGRADE DOCKER CE

To upgrade Docker CE, follow the [installation instructions](https://docs.docker.com/install/linux/docker-ce/centos/#install-docker), choosing the new version you want to install.

#### Install from a package

If you cannot use Docker’s repository to install Docker, you can download the .rpm file for your release and install it manually. You need to download a new file each time you want to upgrade Docker.

1. Go to <https://download.docker.com/linux/centos/7/x86_64/stable/Packages/>and download the .rpm file for the Docker version you want to install.

**Note**: To install an **edge** package, change the word stable in the above URL to edge. [Learn about **stable** and **edge** channels](https://docs.docker.com/install/).

1. Install Docker CE, changing the path below to the path where you downloaded the Docker package.
2. $ sudo yum install /path/to/package.rpm

Docker is installed but not started. The docker group is created, but no users are added to the group.

1. Start Docker.
2. $ sudo systemctl start docker
3. Verify that dockeris installed correctly by running the hello-world
4. $ sudo docker run hello-world

This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.

Docker CE is installed and running. You need to use sudo to run Docker commands. Continue to [Post-installation steps for Linux](https://docs.docker.com/install/linux/linux-postinstall/) to allow non-privileged users to run Docker commands and for other optional configuration steps.

##### UPGRADE DOCKER CE

To upgrade Docker CE, download the newer package file and repeat the [installation procedure](https://docs.docker.com/install/linux/docker-ce/centos/#install-from-a-package), using yum -y upgrade instead of yum -y install, and pointing to the new file.

#### Install using the convenience script

Docker provides convenience scripts at [get.docker.com](https://get.docker.com/) and [test.docker.com](https://test.docker.com/) for installing edge and testing versions of Docker CE into development environments quickly and non-interactively. The source code for the scripts is in the [docker-install repository](https://github.com/docker/docker-install). **Using these scripts is not recommended for production environments**, and you should understand the potential risks before you use them:

- The scripts require root or sudo privileges to run. Therefore, you should carefully examine and audit the scripts before running them.
- The scripts attempt to detect your Linux distribution and version and configure your package management system for you. In addition, the scripts do not allow you to customize any installation parameters. This may lead to an unsupported configuration, either from Docker’s point of view or from your own organization’s guidelines and standards.
- The scripts install all dependencies and recommendations of the package manager without asking for confirmation. This may install a large number of packages, depending on the current configuration of your host machine.
- The script does not provide options to specify which version of Docker to install, and installs the latest version that is released in the “edge” channel.
- Do not use the convenience script if Docker has already been installed on the host machine using another mechanism.

This example uses the script at [get.docker.com](https://get.docker.com/) to install the latest release of Docker CE on Linux. To install the latest testing version, use [test.docker.com](https://test.docker.com/) instead. In each of the commands below, replace each occurrence of get with test.

**Warning****:**

Always examine scripts downloaded from the internet before running them locally.

$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh <output truncated> If you would like to use Docker as a non-root user, you should now consideradding your user to the "docker" group with something like:   sudo usermod -aG docker your-user Remember to log out and back in for this to take effect! WARNING: Adding a user to the "docker" group grants the ability to run         containers which can be used to obtain root privileges on the         docker host.         Refer to https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface         for more information.

Docker CE is installed. It starts automatically on DEB-based distributions. On RPM-based distributions, you need to start it manually using the appropriate systemctl or servicecommand. As the message indicates, non-root users can’t run Docker commands by default.

##### UPGRADE DOCKER AFTER USING THE CONVENIENCE SCRIPT

If you installed Docker using the convenience script, you should upgrade Docker using your package manager directly. There is no advantage to re-running the convenience script, and it can cause issues if it attempts to re-add repositories which have already been added to the host machine.

### Uninstall Docker CE

1. Uninstall the Docker package:
2. $ sudo yum remove docker-ce
3. Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:
4. $ sudo rm -rf /var/lib/docker

You must delete any edited configuration files manually.

### Next steps

- Continue to [Post-installation steps for Linux](https://docs.docker.com/install/linux/linux-postinstall/)
- Continue with the [User Guide](https://docs.docker.com/engine/userguide/).

 

 

## Post-installation steps for Linux

https://docs.docker.com/install/linux/linux-postinstall/

This section contains optional procedures for configuring Linux hosts to work better with Docker.

### Manage Docker as a non-root user

The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. The docker daemon always runs as the root user.

If you don’t want to use sudo when you use the docker command, create a Unix group called docker and add users to it. When the docker daemon starts, it makes the ownership of the Unix socket read/writable by the docker group.

**Warning**: The docker group grants privileges equivalent to the root user. For details on how this impacts security in your system, see [*Docker Daemon Attack Surface*](https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface).

To create the docker group and add your user:

1. Create the docker
2. $ sudo groupadd docker
3. Add your user to the docker
4. $ sudo usermod -aG docker $USER
5. Log out and log back in so that your group membership is re-evaluated.

If testing on a virtual machine, it may be necessary to restart the virtual machine for changes to take effect.

On a desktop Linux environment such as X Windows, log out of your session completely and then log back in.

1. Verify that you can run dockercommands without sudo.
2. $ docker run hello-world

This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.

If you initially ran Docker CLI commands using sudo before adding your user to the docker group, you may see the following error, which indicates that your ~/.docker/ directory was created with incorrect permissions due to the sudocommands.

WARNING: Error loading config file: /home/user/.docker/config.json -stat /home/user/.docker/config.json: permission denied

To fix this problem, either remove the ~/.docker/ directory (it is recreated automatically, but any custom settings are lost), or change its ownership and permissions using the following commands:

$ sudo chown "$USER":"$USER" /home/"$USER"/.docker -R$ sudo chmod g+rwx "/home/$USER/.docker" -R

### Configure Docker to start on boot

Most current Linux distributions (RHEL, CentOS, Fedora, Ubuntu 16.04 and higher) use [systemd](https://docs.docker.com/install/linux/linux-postinstall/#systemd) to manage which services start when the system boots. Ubuntu 14.10 and below use [upstart](https://docs.docker.com/install/linux/linux-postinstall/#upstart).

#### systemd

$ sudo systemctl enable docker

To disable this behavior, use disable instead.

$ sudo systemctl disable docker

If you need to add an HTTP Proxy, set a different directory or partition for the Docker runtime files, or make other customizations, see [customize your systemd Docker daemon options](https://docs.docker.com/engine/admin/systemd/).

#### upstart

Docker is automatically configured to start on boot using upstart. To disable this behavior, use the following command:

$ echo manual | sudo tee /etc/init/docker.override

#### chkconfig

$ sudo chkconfig docker on

### Use a different storage engine

For information about the different storage engines, see [Storage drivers](https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/). The default storage engine and the list of supported storage engines depend on your host’s Linux distribution and available kernel drivers.

### Configure where the Docker daemon listens for connections

By default, the Docker daemon listens for connections on a UNIX socket. To enable Docker to accept requests from remote hosts, you can configure it to listen on an IP address and port as well. It still needs to listen on the UNIX socket as well, to accept requests from local clients.

1. Set the hostsarray in the /etc/docker/daemon.json to connect to the UNIX socket and an IP address, as follows:
2. {  "hosts":["fd://","tcp://0.0.0.0:2375"]     }
3. Restart Docker. Check to see whether the value was honored, by looking for the dockerd If step 1 worked, the Docker daemon shows multiple -Hflags:
4. $ sudo ps aux |grep dockerd  8.     root     31239  0.7  0.2 1007880 72816 ?       Ssl  15:03   0:00 /usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375

**If you see multiple** **-H** **values, you are done. If you do not see multiple** **-H** **values, go to the next step.**

1. On some Linux distributions, such as RHEL and CentOS, the hostskey in the/etc/docker/daemon.json file is overridden by the contents of the serviceservice configuration file. In this case, you need to edit this file manually.
   1. Use the command sudo systemctl edit docker.serviceto open theservice file in a text editor.
   2. Add or modify the following lines, substituting your own values.
   3. [Service] ExecStart=5.     ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375

Save the file.

1. Reload the systemctl
2. $ sudo systemctl daemon-reload
3. Restart Docker.
4. $ sudo systemctl restart docker.service
5. Check again to see if the dockerdcommand now listens on both the file descriptor and the network address.
6. $ sudo ps aux |grep dockerd  6.     root     31239  0.7  0.2 1007880 72816 ?       Ssl  15:03   0:00 /usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375

### Enable IPv6 on the Docker daemon

To enable IPv6 on the Docker daemon, see [Enable IPv6 support](https://docs.docker.com/config/daemon/ipv6/).

### Troubleshooting

#### Kernel compatibility

Docker cannot run correctly if your kernel is older than version 3.10 or if it is missing some modules. To check kernel compatibility, you can download and run the [check-config.sh](https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh)script.

$ curl https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh > check-config.sh $ bash ./check-config.sh

The script only works on Linux, not macOS.

#### Cannot connect to the Docker daemon

If you see an error such as the following, your Docker client may be configured to connect to a Docker daemon on a different host, and that host may not be reachable.

Cannot connect to the Docker daemon. Is 'docker daemon' running on this host?

To see which host your client is configured to connect to, check the value of the DOCKER_HOST variable in your environment.

$ env | grep DOCKER_HOST

If this command returns a value, the Docker client is set to connect to a Docker daemon running on that host. If it is unset, the Docker client is set to connect to the Docker daemon running on the local host. If it is set in error, use the following command to unset it:

$ unset DOCKER_HOST

You may need to edit your environment in files such as ~/.bashrc or ~/.profile to prevent the DOCKER_HOST variable from being set erroneously.

If DOCKER_HOST is set as intended, verify that the Docker daemon is running on the remote host and that a firewall or network outage is not preventing you from connecting.

#### IP forwarding problems

If you manually configure your network using systemd-network with systemd version 219 or higher, Docker containers may not be able to access your network. Beginning with systemd version 220, the forwarding setting for a given network (net.ipv4.conf.<interface>.forwarding) defaults to *off*. This setting prevents IP forwarding. It also conflicts with Docker’s behavior of enabling the net.ipv4.conf.all.forwarding setting within containers.

To work around this on RHEL, CentOS, or Fedora, edit the <interface>.network file in /usr/lib/systemd/network/ on your Docker host (ex: /usr/lib/systemd/network/80-container-host0.network) and add the following block within the [Network] section.

[Network]...IPForward=kernel# ORIPForward=true...

This configuration allows IP forwarding from the container as expected.

#### DNS resolver found in resolv.conf and containers can't use it

Linux systems which use a GUI often have a network manager running, which uses adnsmasq instance running on a loopback address such as 127.0.0.1 or 127.0.1.1 to cache DNS requests, and adds this entry to /etc/resolv.conf. The dnsmasq service speeds up DNS look-ups and also provides DHCP services. This configuration does not work within a Docker container which has its own network namespace, because the Docker container resolves loopback addresses such as 127.0.0.1 to **itself**, and it is very unlikely to be running a DNS server on its own loopback address.

If Docker detects that no DNS server referenced in /etc/resolv.conf is a fully functional DNS server, the following warning occurs and Docker uses the public DNS servers provided by Google at 8.8.8.8 and 8.8.4.4 for DNS resolution.

WARNING: Local (127.0.0.1) DNS resolver found in resolv.conf and containerscan't use it. Using default external servers : [8.8.8.8 8.8.4.4]

If you see this warning, first check to see if you use dnsmasq:

$ ps aux |grep dnsmasq

If your container needs to resolve hosts which are internal to your network, the public nameservers are not adequate. You have two choices:

- You can specify a DNS server for Docker to use, **or**
- You can disable dnsmasq in NetworkManager. If you do this, NetworkManager adds your true DNS nameserver to /etc/resolv.conf, but you lose the possible benefits of dnsmasq.

**You only need to use one of these methods.**

#### Specify DNS servers for Docker

The default location of the configuration file is /etc/docker/daemon.json. You can change the location of the configuration file using the --config-file daemon flag. The documentation below assumes the configuration file is located at /etc/docker/daemon.json.

1. Create or edit the Docker daemon configuration file, which defaults to/etc/docker/daemon.jsonfile, which controls the Docker daemon configuration.
2. $ sudo nano /etc/docker/daemon.json
3. Add a dnskey with one or more IP addresses as values. If the file has existing contents, you only need to add or edit the dns
4. {    "dns":["8.8.8.8","8.8.4.4"]     }

If your internal DNS server cannot resolve public IP addresses, include at least one DNS server which can, so that you can connect to Docker Hub and so that your containers can resolve internet domain names.

Save and close the file.

1. Restart the Docker daemon.
2. $ sudo service docker restart
3. Verify that Docker can resolve external IP addresses by trying to pull an image:
4. $ docker pull hello-world
5. If necessary, verify that Docker containers can resolve an internal hostname by pinging it.
6. $ docker run --rm-it alpine ping -c4 <my_internal_host>  14.  PING google.com (192.168.1.2): 56 data bytes15.  64 bytes from 192.168.1.2: seq=0 ttl=41 time=7.597 ms16.  64 bytes from 192.168.1.2: seq=1 ttl=41 time=7.635 ms17.  64 bytes from 192.168.1.2: seq=2 ttl=41 time=7.660 ms18.  64 bytes from 192.168.1.2: seq=3 ttl=41 time=7.677 ms

##### DISABLE DNSMASQ

###### Ubuntu

If you prefer not to change the Docker daemon’s configuration to use a specific IP address, follow these instructions to disable dnsmasq in NetworkManager.

1. Edit the /etc/NetworkManager/NetworkManager.conf
2. Comment out the dns=dnsmasqline by adding a # character to the beginning of the line.
3. \# dns=dnsmasq

Save and close the file.

1. Restart both NetworkManager and Docker. As an alternative, you can reboot your system.
2. $ sudo restart network-manager $ sudo restart docker

###### RHEL, CentOS, or Fedora

To disable dnsmasq on RHEL, CentOS, or Fedora:

1. Disable the dnsmasqservice:
2. $ sudo service dnsmasq stop  4.     $ sudo systemctl disable dnsmasq
3. Configure the DNS servers manually using the [Red Hat documentation](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/s1-networkscripts-interfaces.html).

#### Allow access to the remote API through a firewall

If you run a firewall on the same host as you run Docker and you want to access the Docker Remote API from another host and remote access is enabled, you need to configure your firewall to allow incoming connections on the Docker port, which defaults to 2376 if TLS encrypted transport is enabled or 2375 otherwise.

Two common firewall daemons are [UFW (Uncomplicated Firewall)](https://help.ubuntu.com/community/UFW) (often used for Ubuntu systems) and [firewalld](http://www.firewalld.org/) (often used for RPM-based systems). Consult the documentation for your OS and firewall, but the following information might help you get started. These options are fairly permissive and you may want to use a different configuration that locks your system down more.

- **UFW**: Set DEFAULT_FORWARD_POLICY="ACCEPT"in your configuration.
- **firewalld**: Add rules similar to the following to your policy (one for incoming requests and one for outgoing requests). Be sure the interface names and chain names are correct.
- <direct>   [ <ruleipv="ipv6"table="filter"chain="FORWARD_direct"priority="0"> -i zt0 -j ACCEPT </rule> ]·          [ <ruleipv="ipv6"table="filter"chain="FORWARD_direct"priority="0"> -o zt0 -j ACCEPT </rule> ]·        </direct>

#### Your kernel does not support cgroup swap limit capabilities

On Ubuntu or Debian hosts, You may see messages similar to the following when working with an image.

WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.

This warning does not occur on RPM-based systems, which enable these capabilities by default.

If you don’t need these capabilities, you can ignore the warning. You can enable these capabilities on Ubuntu or Debian by following these instructions. Memory and swap accounting incur an overhead of about 1% of the total available memory and a 10% overall performance degradation, even if Docker is not running.

1. Log into the Ubuntu or Debian host as a user with sudo
2. Edit the /etc/default/grub Add or edit the GRUB_CMDLINE_LINUXline to add the following two key-value pairs:
3. GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1"

Save and close the file.

1. Update GRUB.
2. $ sudo update-grub

If your GRUB configuration file has incorrect syntax, an error occurs. In this case, repeat steps 3 and 4.

The changes take effect when the system is rebooted.

 

 

## [配置CentOS 7 DOCKER_HOST到0.0.0.0:2375](http://www.cnblogs.com/flasheryu/p/5728669.html)

http://www.cnblogs.com/flasheryu/p/5728669.html

CentOS 7的配置文件位置略不同： 具体参见

https://www.daocloud.io/mirror#accelerator-doc中set_mirror脚本。

vi /usr/lib/systemd/system/docker.service

 

[Unit]
Description=Docker Application Container Engine
Documentation=[http://docs.docker.com](http://docs.docker.com/)
After=network.target docker.socket
Requires=docker.socket

[Service]
Type=notify

#the default is not to use systemd for cgroups because the delegate issues still

#exists and systemd currently does not support the cgroup feature set required

#for containers run by docker

EnvironmentFile=/etc/sysconfig/docker
ExecStart=/usr/bin/docker daemon -H fd:// -H tcp://0.0.0.0:2375
MountFlags=slave
LimitNOFILE=1048576
LimitNPROC=1048576
LimitCORE=infinity
TimeoutStartSec=0

#set delegate yes so that systemd does not reset the cgroups of docker containers

Delegate=yes

[Install]
WantedBy=multi-user.target

 

 

生效服务：systemctl daemon-reload 

 service docker restar